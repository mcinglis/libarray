
// Copyright 2015  Malcolm Inglis <http://minglis.id.au>
//
// This file is part of Libarray.
//
// Libarray is free software: you can redistribute it and/or modify it under
// the terms of the GNU Affero General Public License as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version.
//
// Libarray is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
// more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with Libarray. If not, see <https://gnu.org/licenses/>.


// This file is the result of rendering:
//
//     {{template_path}}
//
// You should make changes to this file by tuning the build process, or (at a
// stretch) modifying the generation script or template file; not by editing
// this file as-is.


#ifndef LIBARRAY_ARRAY_{{macroname}}_H
#define LIBARRAY_ARRAY_{{macroname}}_H


#include <libtypes/types.h>
#include <libmaybe/def/maybe_size.h>
#include <libmaybe/def/maybe_{{filename}}.h>
{% for p in sys_headers %}
#include <{{p}}>
{% endfor %}

#include "def/array_{{filename}}.h"
{% for path in rel_headers %}
#include "{{p}}"
{% endfor %}




//////////////////////////////
// ARRAYC FUNCTIONS
//////////////////////////////


bool
arrayc_{{funcname}}__is_valid(
        ArrayC_{{typename}} );


ArrayC_{{typename}}
arrayc_{{funcname}}__new(
        {{type}} const * elements,
        size_t length );


ArrayC_{{typename}}
arrayc_{{funcname}}__view_arraym(
        ArrayM_{{typename}} );


void
arrayc_{{funcname}}__memcpy_to(
        ArrayC_{{typename}} from,
        void * to,
        size_t to_size );
// Copies `n` bytes from `from` to `to`, where `n` is the minimum of the size
// of `from` and `to_size`.


void
arrayc_{{funcname}}__copy_into_arraym(
        ArrayC_{{typename}} from,
        ArrayM_{{typename}} to );
// Copies `n` elements from `from` to `to`, where `n` is the minimum of the
// lengths of `from` and `to`.


void
arrayc_{{funcname}}__copy_into_arraym_with(
        ArrayC_{{typename}} from,
        ArrayM_{{typename}} to,
        void ( * copier )( {{type}} from_el, {{type}} * to_el ) );
// Calls `copier` (or byte-wise copy if null) with all the respective elements
// in `from` and `to` up to the minimum length of both arrays.


void
arrayc_{{funcname}}__into_arraym(
        ArrayC_{{typename}} from,
        ArrayM_{{typename}} * to );
// Reallocates `to` to the length of `from`, and copies all elements from
// `from` to `to`.


void
arrayc_{{funcname}}__into_arraym_with(
        ArrayC_{{typename}} from,
        ArrayM_{{typename}} * to,
        void ( * copier )( {{type}} from_el, {{type}} * to_el ),
        void ( * freer )( {{type}} * unused_to_el ) );
// Calls `freer` (if non-null) with all elements in `to` at indices past the
// length of `from`, reallocates `to` to the length of `from`, and calls
// `copier` (or byte-wise copy if null) with all the respective elements in
// `from` and `to`.


ArrayC_{{typename}}
arrayc_{{funcname}}__id(
        ArrayC_{{typename}} );


{{type}} const *
arrayc_{{funcname}}__elements(
        ArrayC_{{typename}} );


size_t
arrayc_{{funcname}}__length(
        ArrayC_{{typename}} );


size_t
arrayc_{{funcname}}__size(
        ArrayC_{{typename}} );


bool
arrayc_{{funcname}}__is_empty(
        ArrayC_{{typename}} );


bool
arrayc_{{funcname}}__isnt_empty(
        ArrayC_{{typename}} );


bool
arrayc_{{funcname}}__is_length_1(
        ArrayC_{{typename}} );


bool
arrayc_{{funcname}}__same(
        ArrayC_{{typename}},
        ArrayC_{{typename}} );


{{type}}
arrayc_{{funcname}}__get(
        ArrayC_{{typename}},
        size_t index );


{{type}} const *
arrayc_{{funcname}}__getp(
        ArrayC_{{typename}},
        size_t index );


Maybe_{{typename}}
arrayc_{{funcname}}__getm(
        ArrayC_{{typename}},
        size_t index );


{{type}}
arrayc_{{funcname}}__first(
        ArrayC_{{typename}} );


{{type}} const *
arrayc_{{funcname}}__firstp(
        ArrayC_{{typename}} );


Maybe_{{typename}}
arrayc_{{funcname}}__firstm(
        ArrayC_{{typename}} );


{{type}}
arrayc_{{funcname}}__last(
        ArrayC_{{typename}} );


{{type}} const *
arrayc_{{funcname}}__lastp(
        ArrayC_{{typename}} );


Maybe_{{typename}}
arrayc_{{funcname}}__lastm(
        ArrayC_{{typename}} );


size_t
arrayc_{{funcname}}__count(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


size_t
arrayc_{{funcname}}__count_first(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


size_t
arrayc_{{funcname}}__count_last(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


ArrayC_{{typename}}
arrayc_{{funcname}}__take(
        ArrayC_{{typename}},
        size_t n );


ArrayC_{{typename}}
arrayc_{{funcname}}__drop(
        ArrayC_{{typename}},
        size_t n );


ArrayC_{{typename}}
arrayc_{{funcname}}__take_end(
        ArrayC_{{typename}},
        size_t n );


ArrayC_{{typename}}
arrayc_{{funcname}}__drop_end(
        ArrayC_{{typename}},
        size_t n );


ArrayC_{{typename}}
arrayc_{{funcname}}__take_while(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


ArrayC_{{typename}}
arrayc_{{funcname}}__take_end_while(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


ArrayC_{{typename}}
arrayc_{{funcname}}__drop_while(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


ArrayC_{{typename}}
arrayc_{{funcname}}__drop_end_while(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


ArrayC_{{typename}}
arrayc_{{funcname}}__slice(
        ArrayC_{{typename}},
        size_t start,
        size_t stop );


ArrayC_{{typename}}
arrayc_{{funcname}}__slice_s(
        ArrayC_{{typename}},
        intmax_t start,
        intmax_t stop );


ArrayC_{{typename}}
arrayc_{{funcname}}__left_half(
        ArrayC_{{typename}} );


ArrayC_{{typename}}
arrayc_{{funcname}}__right_half(
        ArrayC_{{typename}} );


Maybe_size
arrayc_{{funcname}}__find(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_size
arrayc_{{funcname}}__find_not(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_size
arrayc_{{funcname}}__find_last(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_size
arrayc_{{funcname}}__find_last_not(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


{{type}} const *
arrayc_{{funcname}}__findp(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


{{type}} const *
arrayc_{{funcname}}__findp_not(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


{{type}} const *
arrayc_{{funcname}}__findp_last(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


{{type}} const *
arrayc_{{funcname}}__findp_last_not(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_{{typename}}
arrayc_{{funcname}}__findm(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_{{typename}}
arrayc_{{funcname}}__findm_not(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_{{typename}}
arrayc_{{funcname}}__findm_last(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_{{typename}}
arrayc_{{funcname}}__findm_last_not(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


bool
arrayc_{{funcname}}__any(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


bool
arrayc_{{funcname}}__all(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


bool
arrayc_{{funcname}}__only_one(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


bool
arrayc_{{funcname}}__all_but_one(
        ArrayC_{{typename}},
        bool ( * f )( {{type}} ) );


{{type}}
arrayc_{{funcname}}__foldl(
        ArrayC_{{typename}} xs,
        {{type}} init,
        {{type}} ( * f )( {{type}} acc, {{type}} x ) );


{{type}}
arrayc_{{funcname}}__foldl1(
        ArrayC_{{typename}} xs,
        {{type}} ( * f )( {{type}} acc, {{type}} x ) );


{{type}}
arrayc_{{funcname}}__foldr(
        ArrayC_{{typename}} xs,
        {{type}} init,
        {{type}} ( * f )( {{type}} x, {{type}} acc ) );


{{type}}
arrayc_{{funcname}}__foldr1(
        ArrayC_{{typename}} xs,
        {{type}} ( * f )( {{type}} x, {{type}} acc ) );


{{type}} const *
arrayc_{{funcname}}__pick(
        ArrayC_{{typename}} xs,
        bool ( * f )( {{type}} const * pick, {{type}} x ) );


bool
arrayc_{{funcname}}__equal_by(
        ArrayC_{{typename}} xs,
        ArrayC_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );


bool
arrayc_{{funcname}}__has_prefix_by(
        ArrayC_{{typename}} xs,
        ArrayC_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the boolean that `ys` is a prefix of `xs` under the equality
// function of `eq`.


bool
arrayc_{{funcname}}__has_suffix_by(
        ArrayC_{{typename}} xs,
        ArrayC_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the boolean that `ys` is a suffix of `xs` under the equality
// function of `eq`.


bool
arrayc_{{funcname}}__has_infix_by(
        ArrayC_{{typename}} xs,
        ArrayC_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the boolean that `ys` is contained wholly and intact in `xs` under
// the equality function of `eq`.


Maybe_size
arrayc_{{funcname}}__infix_index_by(
        ArrayC_{{typename}} xs,
        ArrayC_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the first index in `xs` at which `ys` is a prefix under the equality
// function of `eq`. If there's no such index, returns nothing.


Maybe_size
arrayc_{{funcname}}__last_infix_index_by(
        ArrayC_{{typename}} xs,
        ArrayC_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the last index in `xs` at which `ys` is a prefix under the equality
// function of `eq`. If there's no such index, returns nothing.


size_t
arrayc_{{funcname}}__infix_count_by(
        ArrayC_{{typename}} xs,
        ArrayC_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the number of infixed occurences of `ys` in `xs`.


bool
arrayc_{{funcname}}__elem_by(
        ArrayC_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


Maybe_size
arrayc_{{funcname}}__elem_index_by(
        ArrayC_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


{{type}} const *
arrayc_{{funcname}}__elem_ptr_by(
        ArrayC_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


Maybe_size
arrayc_{{funcname}}__elem_last_index_by(
        ArrayC_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


{{type}} const *
arrayc_{{funcname}}__elem_last_ptr_by(
        ArrayC_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


size_t
arrayc_{{funcname}}__elem_count_by(
        ArrayC_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


ArrayM_{{typename}}
arrayc_{{funcname}}__replacedf(
        ArrayC_{{typename}} xs,
        bool ( * f )( {{type}} x ),
        {{type}} replacement );


ArrayM_{{typename}}
arrayc_{{funcname}}__replaced_by(
        ArrayC_{{typename}} xs,
        {{type}} element,
        {{type}} replacement,
        bool ( * eq )( {{type}} x, {{type}} el ) );


struct arrayc_{{funcname}}__each__options {
    void ( * f )( {{type}} );
    bool ( * b )( {{type}} );
    void ( * fi )( size_t index, {{type}} );
    bool ( * bi )( size_t index, {{type}} );
    void ( * fv )( void const * v, {{type}} );
    bool ( * bv )( void const * v, {{type}} );
    void ( * fvi )( void const * v, size_t index, {{type}} );
    bool ( * bvi )( void const * v, size_t index, {{type}} );
    bool ( * where )( {{type}} );
    bool ( * where_not )( {{type}} );
    void const * v;
};

bool
arrayc_{{funcname}}__each_(
        ArrayC_{{typename}},
        struct arrayc_{{funcname}}__each__options );

#define arrayc_{{funcname}}__each( XS, ... ) \
    arrayc_{{funcname}}__each_( XS, \
        ( struct arrayc_{{funcname}}__each__options ){ __VA_ARGS__ } )


struct arrayc_{{funcname}}__eachp__options {
    void ( * f )( {{type}} const * );
    bool ( * b )( {{type}} const * );
    void ( * fi )( size_t index, {{type}} const * );
    bool ( * bi )( size_t index, {{type}} const * );
    void ( * fv )( void const * v, {{type}} const * );
    bool ( * bv )( void const * v, {{type}} const * );
    void ( * fvi )( void const * v, size_t index, {{type}} const * );
    bool ( * bvi )( void const * v, size_t index, {{type}} const * );
    bool ( * where )( {{type}} );
    bool ( * where_not )( {{type}} );
    void const * v;
};

bool
arrayc_{{funcname}}__eachp_(
        ArrayC_{{typename}},
        struct arrayc_{{funcname}}__eachp__options );

#define arrayc_{{funcname}}__eachp( XS, ... ) \
    arrayc_{{funcname}}__eachp_( XS, \
        ( struct arrayc_{{funcname}}__eachp__options ){ __VA_ARGS__ } )




//////////////////////////////
// ARRAYM FUNCTIONS
//////////////////////////////


bool
arraym_{{funcname}}__is_valid(
        ArrayM_{{typename}} );


ArrayM_{{typename}}
arraym_{{funcname}}__new(
        {{type}} const * elements,
        size_t length );


ArrayM_{{typename}}
arraym_{{funcname}}__new_view(
        {{type}} * elements,
        size_t length );


ArrayM_{{typename}}
arraym_{{funcname}}__new_alloc(
        size_t length );


ArrayM_{{typename}}
arraym_{{funcname}}__new_calloc(
        size_t length );


#define arraym_{{funcname}}__new_els( ... ) \
    arraym_{{funcname}}__copy_arrayc( ARRAYC_{{macroname}}( __VA_ARGS__ ) )


ArrayM_{{typename}}
arraym_{{funcname}}__copy_arraym(
        ArrayM_{{typename}} );


ArrayM_{{typename}}
arraym_{{funcname}}__copy_arrayc(
        ArrayC_{{typename}} );


void
arraym_{{funcname}}__free(
        ArrayM_{{typename}} * xs );


void
arraym_{{funcname}}__realloc(
        ArrayM_{{typename}} *,
        size_t new_length );


void
arraym_{{funcname}}__memcpy_from(
        ArrayM_{{typename}} to,
        void const * from,
        size_t from_size );
// Copies `n` bytes from `from` to `to`, where `n` is the minimum of the size
// of `to` and `from_size`.


void
arraym_{{funcname}}__memcpy_to(
        ArrayM_{{typename}} from,
        void * to,
        size_t to_size );
// Copies `n` bytes from `from` to `to`, where `n` is the minimum of the size
// of `from` and `to_size`.


void
arraym_{{funcname}}__copy_into_arraym(
        ArrayM_{{typename}} from,
        ArrayM_{{typename}} to );
// Copies `n` elements from `from` to `to`, where `n` is the minimum of the
// lengths of `from` and `to`.


void
arraym_{{funcname}}__copy_into_arraym_with(
        ArrayM_{{typename}} from,
        ArrayM_{{typename}} to,
        void ( * copier )( {{type}} from_el, {{type}} * to_el ) );
// Calls `copier` (or byte-wise copy if null) with all the respective elements
// in `from` and `to` up to the minimum length of both arrays.


void
arraym_{{funcname}}__into_arraym(
        ArrayM_{{typename}} from,
        ArrayM_{{typename}} * to );
// Reallocates `to` to the length of `from`, and copies all elements from
// `from` to `to`.


void
arraym_{{funcname}}__into_arraym_with(
        ArrayM_{{typename}} from,
        ArrayM_{{typename}} * to,
        void ( * copier )( {{type}} from_el, {{type}} * to_el ),
        void ( * freer )( {{type}} * unused_to_el ) );
// Calls `freer` (if non-null) with all elements in `to` at indices past the
// length of `from`, reallocates `to` to the length of `from`, and calls
// `copier` (or byte-wise copy if null) with all the respective elements in
// `from` and `to`.


ArrayM_{{typename}}
arraym_{{funcname}}__id(
        ArrayM_{{typename}} );


{{type}} *
arraym_{{funcname}}__elements(
        ArrayM_{{typename}} );


size_t
arraym_{{funcname}}__length(
        ArrayM_{{typename}} );


size_t
arraym_{{funcname}}__size(
        ArrayM_{{typename}} );


bool
arraym_{{funcname}}__is_empty(
        ArrayM_{{typename}} );


bool
arraym_{{funcname}}__isnt_empty(
        ArrayM_{{typename}} );


bool
arraym_{{funcname}}__is_length_1(
        ArrayM_{{typename}} );


bool
arraym_{{funcname}}__same(
        ArrayM_{{typename}},
        ArrayM_{{typename}} );


{{type}}
arraym_{{funcname}}__get(
        ArrayM_{{typename}},
        size_t index );


{{type}} *
arraym_{{funcname}}__getp(
        ArrayM_{{typename}},
        size_t index );


Maybe_{{typename}}
arraym_{{funcname}}__getm(
        ArrayM_{{typename}},
        size_t index );


{{type}}
arraym_{{funcname}}__set(
        ArrayM_{{typename}},
        size_t index,
        {{type}} value );


Maybe_{{typename}}
arraym_{{funcname}}__setm(
        ArrayM_{{typename}},
        size_t index,
        {{type}} value );


void
arraym_{{funcname}}__set_all(
        ArrayM_{{typename}},
        {{type}} value );


{{type}}
arraym_{{funcname}}__set_first(
        ArrayM_{{typename}},
        {{type}} value );


{{type}}
arraym_{{funcname}}__set_last(
        ArrayM_{{typename}},
        {{type}} value );


void
arraym_{{funcname}}__memset(
        ArrayM_{{typename}},
        uchar const byte );


void
arraym_{{funcname}}__memzero(
        ArrayM_{{typename}} );


{{type}}
arraym_{{funcname}}__first(
        ArrayM_{{typename}} );


{{type}} *
arraym_{{funcname}}__firstp(
        ArrayM_{{typename}} );


Maybe_{{typename}}
arraym_{{funcname}}__firstm(
        ArrayM_{{typename}} );


{{type}}
arraym_{{funcname}}__last(
        ArrayM_{{typename}} );


{{type}} *
arraym_{{funcname}}__lastp(
        ArrayM_{{typename}} );


Maybe_{{typename}}
arraym_{{funcname}}__lastm(
        ArrayM_{{typename}} );


size_t
arraym_{{funcname}}__count(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


size_t
arraym_{{funcname}}__count_first(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


size_t
arraym_{{funcname}}__count_last(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


ArrayM_{{typename}}
arraym_{{funcname}}__take(
        ArrayM_{{typename}},
        size_t n );


ArrayM_{{typename}}
arraym_{{funcname}}__drop(
        ArrayM_{{typename}},
        size_t n );


ArrayM_{{typename}}
arraym_{{funcname}}__take_end(
        ArrayM_{{typename}},
        size_t n );


ArrayM_{{typename}}
arraym_{{funcname}}__drop_end(
        ArrayM_{{typename}},
        size_t n );


ArrayM_{{typename}}
arraym_{{funcname}}__take_while(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


ArrayM_{{typename}}
arraym_{{funcname}}__take_end_while(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


ArrayM_{{typename}}
arraym_{{funcname}}__drop_while(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


ArrayM_{{typename}}
arraym_{{funcname}}__drop_end_while(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


ArrayM_{{typename}}
arraym_{{funcname}}__slice(
        ArrayM_{{typename}},
        size_t start,
        size_t stop );


ArrayM_{{typename}}
arraym_{{funcname}}__slice_s(
        ArrayM_{{typename}},
        intmax_t start,
        intmax_t stop );


ArrayM_{{typename}}
arraym_{{funcname}}__left_half(
        ArrayM_{{typename}} );


ArrayM_{{typename}}
arraym_{{funcname}}__right_half(
        ArrayM_{{typename}} );


Maybe_size
arraym_{{funcname}}__find(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_size
arraym_{{funcname}}__find_not(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_size
arraym_{{funcname}}__find_last(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_size
arraym_{{funcname}}__find_last_not(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


{{type}} *
arraym_{{funcname}}__findp(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


{{type}} *
arraym_{{funcname}}__findp_not(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


{{type}} *
arraym_{{funcname}}__findp_last(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


{{type}} *
arraym_{{funcname}}__findp_last_not(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_{{typename}}
arraym_{{funcname}}__findm(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_{{typename}}
arraym_{{funcname}}__findm_not(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_{{typename}}
arraym_{{funcname}}__findm_last(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


Maybe_{{typename}}
arraym_{{funcname}}__findm_last_not(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


bool
arraym_{{funcname}}__any(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


bool
arraym_{{funcname}}__all(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


bool
arraym_{{funcname}}__only_one(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


bool
arraym_{{funcname}}__all_but_one(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} ) );


{{type}}
arraym_{{funcname}}__foldl(
        ArrayM_{{typename}} xs,
        {{type}} init,
        {{type}} ( * f )( {{type}} acc, {{type}} x ) );


{{type}}
arraym_{{funcname}}__foldl1(
        ArrayM_{{typename}} xs,
        {{type}} ( * f )( {{type}} acc, {{type}} x ) );


{{type}}
arraym_{{funcname}}__foldr(
        ArrayM_{{typename}} xs,
        {{type}} init,
        {{type}} ( * f )( {{type}} x, {{type}} acc ) );


{{type}}
arraym_{{funcname}}__foldr1(
        ArrayM_{{typename}} xs,
        {{type}} ( * f )( {{type}} x, {{type}} acc ) );


{{type}} *
arraym_{{funcname}}__pick(
        ArrayM_{{typename}} xs,
        bool ( * f )( {{type}} const * pick, {{type}} x ) );


bool
arraym_{{funcname}}__equal_by(
        ArrayM_{{typename}} xs,
        ArrayM_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );


bool
arraym_{{funcname}}__has_prefix_by(
        ArrayM_{{typename}} xs,
        ArrayM_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the boolean that `ys` is a prefix of `xs` under the equality
// function of `eq`.


bool
arraym_{{funcname}}__has_suffix_by(
        ArrayM_{{typename}} xs,
        ArrayM_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the boolean that `ys` is a suffix of `xs` under the equality
// function of `eq`.


bool
arraym_{{funcname}}__has_infix_by(
        ArrayM_{{typename}} xs,
        ArrayM_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the boolean that `ys` is contained wholly and intact in `xs` under
// the equality function of `eq`.


Maybe_size
arraym_{{funcname}}__infix_index_by(
        ArrayM_{{typename}} xs,
        ArrayM_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the first index in `xs` at which `ys` is a prefix under the equality
// function of `eq`. If there's no such index, returns nothing.


Maybe_size
arraym_{{funcname}}__last_infix_index_by(
        ArrayM_{{typename}} xs,
        ArrayM_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the last index in `xs` at which `ys` is a prefix under the equality
// function of `eq`. If there's no such index, returns nothing.


size_t
arraym_{{funcname}}__infix_count_by(
        ArrayM_{{typename}} xs,
        ArrayM_{{typename}} ys,
        bool ( * eq )( {{type}} x, {{type}} y ) );
// Returns the number of indices of `xs` at which `ys` is a prefix.


bool
arraym_{{funcname}}__elem_by(
        ArrayM_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


Maybe_size
arraym_{{funcname}}__elem_index_by(
        ArrayM_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


{{type}} *
arraym_{{funcname}}__elem_ptr_by(
        ArrayM_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


Maybe_size
arraym_{{funcname}}__elem_last_index_by(
        ArrayM_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


{{type}} *
arraym_{{funcname}}__elem_last_ptr_by(
        ArrayM_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


size_t
arraym_{{funcname}}__elem_count_by(
        ArrayM_{{typename}} xs,
        {{type}} y,
        bool ( * eq )( {{type}} x, {{type}} y ) );


void
arraym_{{funcname}}__replacef(
        ArrayM_{{typename}},
        bool ( * f )( {{type}} x ),
        {{type}} replacement );


ArrayM_{{typename}}
arraym_{{funcname}}__replacedf(
        ArrayM_{{typename}} xs,
        bool ( * f )( {{type}} x ),
        {{type}} replacement );


void
arraym_{{funcname}}__replace_by(
        ArrayM_{{typename}} xs,
        {{type}} element,
        {{type}} replacement,
        bool ( * eq )( {{type}} x, {{type}} el ) );


ArrayM_{{typename}}
arraym_{{funcname}}__replaced_by(
        ArrayM_{{typename}} xs,
        {{type}} element,
        {{type}} replacement,
        bool ( * eq )( {{type}} x, {{type}} el ) );


bool
arraym_{{funcname}}__each_(
        ArrayM_{{typename}},
        struct arrayc_{{funcname}}__each__options );

#define arraym_{{funcname}}__each( XS, ... ) \
    arraym_{{funcname}}__each_( XS, \
        ( struct arrayc_{{funcname}}__each__options ){ __VA_ARGS__ } )


struct arraym_{{funcname}}__eachp__options {
    void ( * f )( {{type}} * );
    bool ( * b )( {{type}} * );
    void ( * fi )( size_t index, {{type}} * );
    bool ( * bi )( size_t index, {{type}} * );
    void ( * fv )( void const * v, {{type}} * );
    bool ( * bv )( void const * v, {{type}} * );
    void ( * fvi )( void const * v, size_t index, {{type}} * );
    bool ( * bvi )( void const * v, size_t index, {{type}} * );
    bool ( * where )( {{type}} );
    bool ( * where_not )( {{type}} );
    void const * v;
};

bool
arraym_{{funcname}}__eachp_(
        ArrayM_{{typename}},
        struct arraym_{{funcname}}__eachp__options );

#define arraym_{{funcname}}__eachp( XS, ... ) \
    arraym_{{funcname}}__eachp_( XS, \
        ( struct arraym_{{funcname}}__eachp__options ){ __VA_ARGS__ } )




{% if 'EQ' in typeclasses %}


bool
arrayc_{{funcname}}__equal(
        ArrayC_{{typename}},
        ArrayC_{{typename}} );


bool
arrayc_{{funcname}}__not_equal(
        ArrayC_{{typename}},
        ArrayC_{{typename}} );


#define arrayc_{{funcname}}__equal_els( XS, ... ) \
    arrayc_{{funcname}}__equal( XS, \
                                ARRAYC_{{macroname}}( __VA_ARGS__ ) )


bool
arrayc_{{funcname}}__is_prefix(
        ArrayC_{{typename}},
        ArrayC_{{typename}} );


bool
arrayc_{{funcname}}__is_suffix(
        ArrayC_{{typename}},
        ArrayC_{{typename}} );


bool
arrayc_{{funcname}}__is_infix(
        ArrayC_{{typename}},
        ArrayC_{{typename}} );


Maybe_size
arrayc_{{funcname}}__infix_index(
        ArrayC_{{typename}},
        ArrayC_{{typename}} );


Maybe_size
arrayc_{{funcname}}__last_infix_index(
        ArrayC_{{typename}},
        ArrayC_{{typename}} );


size_t
arrayc_{{funcname}}__infix_count(
        ArrayC_{{typename}},
        ArrayC_{{typename}} );


bool
arrayc_{{funcname}}__elem(
        ArrayC_{{typename}},
        {{type}} );


Maybe_size
arrayc_{{funcname}}__elem_index(
        ArrayC_{{typename}},
        {{type}} );


{{type}} const *
arrayc_{{funcname}}__elem_ptr(
        ArrayC_{{typename}},
        {{type}} );


Maybe_size
arrayc_{{funcname}}__elem_last_index(
        ArrayC_{{typename}},
        {{type}} );


{{type}} const *
arrayc_{{funcname}}__elem_last_ptr(
        ArrayC_{{typename}},
        {{type}} );


size_t
arrayc_{{funcname}}__elem_count(
        ArrayC_{{typename}},
        {{type}} );


ArrayM_{{typename}}
arrayc_{{funcname}}__replaced(
        ArrayC_{{typename}},
        {{type}} element,
        {{type}} replacement );




bool
arraym_{{funcname}}__equal(
        ArrayM_{{typename}},
        ArrayM_{{typename}} );


bool
arraym_{{funcname}}__not_equal(
        ArrayM_{{typename}},
        ArrayM_{{typename}} );


#define arraym_{{funcname}}__equal_els( XS, ... ) \
    arraym_{{funcname}}__equal( XS, \
                                ARRAYM_{{macroname}}( __VA_ARGS__ ) )


bool
arraym_{{funcname}}__is_prefix(
        ArrayM_{{typename}},
        ArrayM_{{typename}} );


bool
arraym_{{funcname}}__is_suffix(
        ArrayM_{{typename}},
        ArrayM_{{typename}} );


bool
arraym_{{funcname}}__is_infix(
        ArrayM_{{typename}},
        ArrayM_{{typename}} );


Maybe_size
arraym_{{funcname}}__infix_index(
        ArrayM_{{typename}},
        ArrayM_{{typename}} );


Maybe_size
arraym_{{funcname}}__last_infix_index(
        ArrayM_{{typename}},
        ArrayM_{{typename}} );


size_t
arraym_{{funcname}}__infix_count(
        ArrayM_{{typename}},
        ArrayM_{{typename}} );


bool
arraym_{{funcname}}__elem(
        ArrayM_{{typename}},
        {{type}} );


Maybe_size
arraym_{{funcname}}__elem_index(
        ArrayM_{{typename}},
        {{type}} );


{{type}} *
arraym_{{funcname}}__elem_ptr(
        ArrayM_{{typename}},
        {{type}} );


Maybe_size
arraym_{{funcname}}__elem_last_index(
        ArrayM_{{typename}},
        {{type}} );


{{type}} *
arraym_{{funcname}}__elem_last_ptr(
        ArrayM_{{typename}},
        {{type}} );


size_t
arraym_{{funcname}}__elem_count(
        ArrayM_{{typename}},
        {{type}} );


void
arraym_{{funcname}}__replace(
        ArrayM_{{typename}},
        {{type}} element,
        {{type}} replacement );


ArrayM_{{typename}}
arraym_{{funcname}}__replaced(
        ArrayM_{{typename}},
        {{type}} element,
        {{type}} replacement );


{% endif %} {# EQ #}




{% if 'NULL' in typeclasses %}


ArrayC_{{typename}}
arrayc_{{funcname}}__view_buf(
        {{type}} const * buf );
// Returns a constant array representation of the buffer `buf` terminated by
// `{{funcname}}__null()`, not including that null terminator.


ArrayC_{{typename}}
arrayc_{{funcname}}__view_buf0(
        {{type}} const * buf );
// Returns a constant array representation of the buffer `buf` terminated by
// `{{funcname}}__null()`, including the null terminator.


ArrayM_{{typename}}
arraym_{{funcname}}__view_buf(
        {{type}} * buf );
// Returns a mutable array representation of the buffer `buf` terminated by
// `{{funcname}}__null()`, not including the null terminator.


ArrayM_{{typename}}
arraym_{{funcname}}__view_buf0(
        {{type}} * buf );
// Returns a mutable array representation of the buffer `buf` terminated by
// `{{funcname}}__null()`, not including the null terminator.


ArrayM_{{typename}}
arraym_{{funcname}}__copy_buf(
        {{type}} const * const buf );


ArrayM_{{typename}}
arraym_{{funcname}}__copy_buf0(
        {{type}} const * const buf );


{% if 'EQ' in typeclasses %}


bool
arrayc_{{funcname}}__equal_buf(
        ArrayC_{{typename}},
        {{type}} const * buf );


bool
arrayc_{{funcname}}__equal_buf0(
        ArrayC_{{typename}},
        {{type}} const * buf );


bool
arraym_{{funcname}}__equal_buf(
        ArrayM_{{typename}},
        {{type}} const * buf );


bool
arraym_{{funcname}}__equal_buf0(
        ArrayM_{{typename}},
        {{type}} const * buf );


{% endif %} {# EQ #}
{% endif %} {# NULL #}




{% if 'CHAR' in typeclasses %}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_str(
        char const * str );


{% if 'EQ' in typeclasses %}


bool
arrayc_{{funcname}}__equal_str(
        ArrayC_{{typename}},
        char const * str );


bool
arraym_{{funcname}}__equal_str(
        ArrayM_{{typename}},
        char const * str );


{% endif %} {# EQ #}
{% endif %} {# CHAR #}




#endif // ifndef LIBARRAY_ARRAY_{{macroname}}_H

