
// Copyright 2015  Malcolm Inglis <http://minglis.id.au>
//
// This file is part of Libarray.
//
// Libarray is free software: you can redistribute it and/or modify it under
// the terms of the GNU Affero General Public License as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version.
//
// Libarray is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
// more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with Libarray. If not, see <https://gnu.org/licenses/>.


// This file is the result of rendering:
//
//     {{template_path}}
//
// You should make changes to this file by tuning the build process, or (at a
// stretch) modifying the generation script or template file; not by editing
// this file as-is.


#include "array_{{filename}}.h"

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include <libtypes/types.h>
#include <libmacro/assert.h>
#include <libmacro/logic.h>
#include <libmacro/minmax.h>
#include <libbase/size.h>
#include <libmaybe/maybe_{{filename}}.h>

{% for p in sys_headers %}
#include <{{p}}>
{% endfor %}

{% for p in rel_headers %}
#include "{{p}}"
{% endfor %}


static
void *
reallocn(
        void * const ptr,
        size_t const n,
        size_t const size )
{
    errno = 0;
    size_t const new_size = size__mul( n, size );
    if ( errno ) { return NULL; }
    if ( new_size == 0 ) {
        if ( ptr != NULL ) {
            free( ptr );
        }
        return NULL;
    } else {
        return realloc( ptr, new_size );
    }
}


static
size_t
normalize_index(
        intmax_t const ix,
        size_t const length )
{
    if ( ix >= 0 ) {
        return MIN( ( uintmax_t ) ix, SIZE_MAX );
    } else {
        if ( INTMAX_MAX < SIZE_MAX ) {
            size_t const pos_ix = -ix;
            if ( pos_ix > length ) {
                return 0;
            }
        } else {
            intmax_t const slength = length;
            if ( -slength > ix ) {
                return 0;
            }
        }
        return length + ix;
    }
}


static
Maybe_size
find_index(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ),
        bool const res )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} const * const el = xs.e + i;
        if ( f( *el ) == res ) {
            return ( Maybe_size ){ .value = i };
        }
    }
    return ( Maybe_size ){ .nothing = true };
}


static
Maybe_size
find_last_index(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ),
        bool const res )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    for ( size_t i = xs.length; i > 0; i-- ) {
        size_t const ix = i - 1;
        if ( f( xs.e[ ix ] ) == res ) {
            return ( Maybe_size ){ .value = ix };
        }
    }
    return ( Maybe_size ){ .nothing = true };
}




bool
arrayc_{{funcname}}__is_valid(
        ArrayC_{{typename}} const xs )
{
    return ALL( ARRAY_{{macroname}}__INVARIANTS( xs ) );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__new(
        {{type}} const * const elements,
        size_t const length )
{
    if ( elements == NULL ) {
        return ( ArrayC_{{typename}} ){ .e = NULL, .length = 0 };
    } else {
        return ( ArrayC_{{typename}} ){ .e = elements, .length = length };
    }
}


ArrayC_{{typename}}
arrayc_{{funcname}}__new_empty(
        void )
{
    return arrayc_{{funcname}}__new( NULL, 0 );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__view_arraym(
        ArrayM_{{typename}} const xs )
{
    return arrayc_{{funcname}}__new( xs.e, xs.length );
}


void
arrayc_{{funcname}}__memcpy_to(
        ArrayC_{{typename}} const from,
        void * const to,
        size_t const to_size )
{
    ASSERT( arrayc_{{funcname}}__is_valid( from ) );

    if ( to != NULL && from.e != NULL ) {
        memcpy( to, from.e,
                MIN( to_size, arrayc_{{funcname}}__size( from ) ) );
    }
}


void
arrayc_{{funcname}}__copy_into_arraym(
        ArrayC_{{typename}} const from,
        ArrayM_{{typename}} const to )
{
    ASSERT( arrayc_{{funcname}}__is_valid( from ),
            arraym_{{funcname}}__is_valid( to ) );

    arrayc_{{funcname}}__copy_into_arraym_with( from, to, NULL );
}


void
arrayc_{{funcname}}__copy_into_arraym_with(
        ArrayC_{{typename}} const from,
        ArrayM_{{typename}} const to,
        void ( * const copier )( {{type}} * to_el, {{type}} from_el ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( from ),
            arraym_{{funcname}}__is_valid( to ) );

    errno = 0;
    for ( size_t i = 0; i < MIN( from.length, to.length ); i++ ) {
        {{type}} const from_el = arrayc_{{funcname}}__get( from, i );
        {{type}} * const to_el = arraym_{{funcname}}__getp( to, i );
        if ( copier == NULL ) {
            *to_el = from_el;
        } else {
            copier( to_el, from_el );
            if ( errno ) { return; }
        }
    }
}


ArrayC_{{typename}}
arrayc_{{funcname}}__id(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return xs;
}


{{type}} const *
arrayc_{{funcname}}__elements(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return xs.e;
}


size_t
arrayc_{{funcname}}__length(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return xs.length;
}


size_t
arrayc_{{funcname}}__size(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            size__can_mul( xs.length, sizeof ( {{type}} ) ) );

    return xs.length * sizeof ( {{type}} );
}


bool
arrayc_{{funcname}}__is_empty(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return xs.length == 0;
}


bool
arrayc_{{funcname}}__isnt_empty(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return !arrayc_{{funcname}}__is_empty( xs );
}


bool
arrayc_{{funcname}}__is_length_1(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return xs.length == 1;
}


bool
arrayc_{{funcname}}__same(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ) );

    return xs.length == ys.length
        && xs.e      == ys.e;
}


{{type}}
arrayc_{{funcname}}__get(
        ArrayC_{{typename}} const xs,
        size_t const index )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), index < xs.length );

    {{type}} const * const p = arrayc_{{funcname}}__getp( xs, index );
    ASSERT( p != NULL );
    return *p;
}


{{type}} const *
arrayc_{{funcname}}__getp(
        ArrayC_{{typename}} const xs,
        size_t const index )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return ( index < xs.length ) ? ( xs.e + index ) : ( NULL );
}


Maybe_{{typename}}
arrayc_{{funcname}}__getm(
        ArrayC_{{typename}} const xs,
        size_t const index )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return maybe_{{funcname}}__from_ptr(
               arrayc_{{funcname}}__getp( xs, index ) );
}


{{type}}
arrayc_{{funcname}}__first(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__isnt_empty( xs ) );

    return *( arrayc_{{funcname}}__firstp( xs ) );
}


{{type}} const *
arrayc_{{funcname}}__firstp(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__getp( xs, 0 );
}


Maybe_{{typename}}
arrayc_{{funcname}}__firstm(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return maybe_{{funcname}}__from_ptr( arrayc_{{funcname}}__firstp( xs ) );
}


{{type}}
arrayc_{{funcname}}__last(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__isnt_empty( xs ) );

    return *( arrayc_{{funcname}}__lastp( xs ) );
}


{{type}} const *
arrayc_{{funcname}}__lastp(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    if ( xs.length == 0 ) {
        return NULL;
    } else {
        return arrayc_{{funcname}}__getp( xs, xs.length - 1 );
    }
}


Maybe_{{typename}}
arrayc_{{funcname}}__lastm(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return maybe_{{funcname}}__from_ptr( arrayc_{{funcname}}__lastp( xs ) );
}


size_t
arrayc_{{funcname}}__count(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    size_t count = 0;
    for ( size_t i = 0; i < xs.length; i++ ) {
        if ( f( xs.e[ i ] ) ) {
            count++;
        }
    }
    return count;
}


size_t
arrayc_{{funcname}}__count_first(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    size_t count = 0;
    for ( size_t i = 0; i < xs.length; i++ ) {
        if ( f( xs.e[ i ] ) ) {
            count++;
        } else {
            break;
        }
    }
    return count;
}


size_t
arrayc_{{funcname}}__count_last(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    size_t count = 0;
    for ( size_t i = xs.length; i > 0; i-- ) {
        if ( f( xs.e[ i - 1 ] ) ) {
            count++;
        } else {
            break;
        }
    }
    return count;
}


ArrayC_{{typename}}
arrayc_{{funcname}}__take(
        ArrayC_{{typename}} const xs,
        size_t const n )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return xs;
    } else {
        return ( ArrayC_{{typename}} ){
                   .e      = xs.e,
                   .length = n };
    }
}


ArrayC_{{typename}}
arrayc_{{funcname}}__drop(
        ArrayC_{{typename}} const xs,
        size_t const n )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return ( ArrayC_{{typename}} ){ .e = NULL, .length = 0 };
    } else {
        return ( ArrayC_{{typename}} ){
                   .e      = xs.e + n,
                   .length = xs.length - n };
    }
}


ArrayC_{{typename}}
arrayc_{{funcname}}__take_end(
        ArrayC_{{typename}} const xs,
        size_t const n )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return xs;
    } else {
        return arrayc_{{funcname}}__drop( xs, xs.length - n );
    }
}


ArrayC_{{typename}}
arrayc_{{funcname}}__drop_end(
        ArrayC_{{typename}} const xs,
        size_t const n )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return ( ArrayC_{{typename}} ){ .e = NULL, .length = 0 };
    } else {
        return arrayc_{{funcname}}__take( xs, xs.length - n );
    }
}


ArrayC_{{typename}}
arrayc_{{funcname}}__take_while(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__take(
               xs,
               arrayc_{{funcname}}__count_first( xs, f ) );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__take_end_while(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__take_end(
               xs,
               arrayc_{{funcname}}__count_last( xs, f ) );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__drop_while(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__drop(
               xs,
               arrayc_{{funcname}}__count_first( xs, f ) );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__drop_end_while(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__drop_end(
               xs,
               arrayc_{{funcname}}__count_last( xs, f ) );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__slice(
        ArrayC_{{typename}} const xs,
        size_t const start,
        size_t const stop )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__drop(
               arrayc_{{funcname}}__take( xs, stop ),
               start );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__slice_s(
        ArrayC_{{typename}} const xs,
        intmax_t const start,
        intmax_t const stop )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__slice(
               xs,
               normalize_index( start, xs.length ),
               normalize_index( stop, xs.length ) );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__left_half(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__take( xs, xs.length / 2 );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__right_half(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__drop( xs, xs.length / 2 );
}


Maybe_size
arrayc_{{funcname}}__find(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return find_index( xs, f, true );
}


Maybe_size
arrayc_{{funcname}}__find_not(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return find_index( xs, f, false );
}


Maybe_size
arrayc_{{funcname}}__find_last(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return find_last_index( xs, f, true );
}


Maybe_size
arrayc_{{funcname}}__find_last_not(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return find_last_index( xs, f, false );
}


{{type}} const *
arrayc_{{funcname}}__findp(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = arrayc_{{funcname}}__find( xs, f );
    return mi.nothing ? NULL : arrayc_{{funcname}}__getp( xs, mi.value );
}


{{type}} const *
arrayc_{{funcname}}__findp_not(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = arrayc_{{funcname}}__find_not( xs, f );
    return mi.nothing ? NULL : arrayc_{{funcname}}__getp( xs, mi.value );
}


{{type}} const *
arrayc_{{funcname}}__findp_last(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = arrayc_{{funcname}}__find_last( xs, f );
    return mi.nothing ? NULL : arrayc_{{funcname}}__getp( xs, mi.value );
}


{{type}} const *
arrayc_{{funcname}}__findp_last_not(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = arrayc_{{funcname}}__find_last_not( xs, f );
    return mi.nothing ? NULL : arrayc_{{funcname}}__getp( xs, mi.value );
}


Maybe_{{typename}}
arrayc_{{funcname}}__findm(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return maybe_{{funcname}}__from_ptr(
               arrayc_{{funcname}}__findp( xs, f ) );
}


Maybe_{{typename}}
arrayc_{{funcname}}__findm_not(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return maybe_{{funcname}}__from_ptr(
               arrayc_{{funcname}}__findp_not( xs, f ) );
}


Maybe_{{typename}}
arrayc_{{funcname}}__findm_last(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return maybe_{{funcname}}__from_ptr(
               arrayc_{{funcname}}__findp_last( xs, f ) );
}


Maybe_{{typename}}
arrayc_{{funcname}}__findm_last_not(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return maybe_{{funcname}}__from_ptr(
               arrayc_{{funcname}}__findp_last_not( xs, f ) );
}


bool
arrayc_{{funcname}}__any(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__findp( xs, f ) != NULL;
}


bool
arrayc_{{funcname}}__all(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__findp_not( xs, f ) == NULL;
}


bool
arrayc_{{funcname}}__only_one(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} const * const first = arrayc_{{funcname}}__findp( xs, f );
    if ( first == NULL ) {
        return false;
    } else {
        return first == arrayc_{{funcname}}__findp_last( xs, f );
    }
}


bool
arrayc_{{funcname}}__all_but_one(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} const * const first = arrayc_{{funcname}}__findp_not( xs, f );
    if ( first == NULL ) {
        return false;
    } else {
        return first == arrayc_{{funcname}}__findp_last_not( xs, f );
    }
}


{{type}}
arrayc_{{funcname}}__foldl(
        ArrayC_{{typename}} const xs,
        {{type}} const init,
        {{type}} ( * const f )( {{type}} acc, {{type}} x ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} acc = init;
    for ( size_t i = 0; i < xs.length; i++ ) {
        acc = f( acc, xs.e[ i ] );
    }
    return acc;
}


{{type}}
arrayc_{{funcname}}__foldl1(
        ArrayC_{{typename}} const xs,
        {{type}} ( * const f )( {{type}} acc, {{type}} x ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), xs.length > 0, f != NULL );

    return arrayc_{{funcname}}__foldl(
               arrayc_{{funcname}}__drop( xs, 1 ),
               arrayc_{{funcname}}__first( xs ),
               f );
}


{{type}}
arrayc_{{funcname}}__foldr(
        ArrayC_{{typename}} const xs,
        {{type}} const init,
        {{type}} ( * const f )( {{type}} x, {{type}} acc ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} acc = init;
    for ( size_t i = xs.length; i > 0; i-- ) {
        acc = f( xs.e[ i - 1 ], acc );
    }
    return acc;
}


{{type}}
arrayc_{{funcname}}__foldr1(
        ArrayC_{{typename}} const xs,
        {{type}} ( * const f )( {{type}} x, {{type}} acc ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), xs.length > 0, f != NULL );

    return arrayc_{{funcname}}__foldr(
               arrayc_{{funcname}}__drop_end( xs, 1 ),
               arrayc_{{funcname}}__last( xs ),
               f );
}


{{type}} const *
arrayc_{{funcname}}__pick(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} const * pick, {{type}} x ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} const * pick = NULL;
    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} const * const el = arrayc_{{funcname}}__getp( xs, i );
        if ( f( pick, *el ) ) {
            pick = el;
        }
    }
    return pick;
}


{{type}} const *
arrayc_{{funcname}}__pickv(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} const * pick, {{type}} x, void * ptr ),
        void * const ptr )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} const * pick = NULL;
    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} const * const el = arrayc_{{funcname}}__getp( xs, i );
        if ( f( pick, *el, ptr ) ) {
            pick = el;
        }
    }
    return pick;
}


bool
arrayc_{{funcname}}__each_(
        ArrayC_{{typename}} const xs,
        struct arrayc_{{funcname}}__each__options const o )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} const el = arrayc_{{funcname}}__get( xs, i );
        if ( ( o.where != NULL && !o.where( el ) )
          || ( o.where_not != NULL && o.where_not( el ) ) ) {
            continue;
        }
        errno = 0;
        if ( o.f != NULL ) {
            o.f( el );
        } else if ( o.b != NULL ) {
            if ( o.b( el ) == false ) { return false; }
        } else if ( o.fi != NULL ) {
            o.fi( i, el );
        } else if ( o.bi != NULL ) {
            if ( o.bi( i, el ) == false ) { return false; }
        } else if ( o.fv != NULL ) {
            o.fv( o.v, el );
        } else if ( o.bv != NULL ) {
            if ( o.bv( o.v, el ) == false ) { return false; }
        } else if ( o.fvi != NULL ) {
            o.fvi( o.v, i, el );
        } else if ( o.bvi != NULL ) {
            if ( o.bvi( o.v, i, el ) == false ) { return false; }
        }
        if ( errno ) { return false; }
    }
    return true;
}


bool
arrayc_{{funcname}}__eachp_(
        ArrayC_{{typename}} const xs,
        struct arrayc_{{funcname}}__eachp__options const o )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} const * const el = arrayc_{{funcname}}__getp( xs, i );
        if ( ( o.where != NULL && !o.where( *el ) )
          || ( o.where_not != NULL && o.where_not( *el ) ) ) {
            continue;
        }
        errno = 0;
        if ( o.f != NULL ) {
            o.f( el );
        } else if ( o.b != NULL ) {
            if ( o.b( el ) == false ) { return false; }
        } else if ( o.fi != NULL ) {
            o.fi( i, el );
        } else if ( o.bi != NULL ) {
            if ( o.bi( i, el ) == false ) { return false; }
        } else if ( o.fv != NULL ) {
            o.fv( o.v, el );
        } else if ( o.bv != NULL ) {
            if ( o.bv( o.v, el ) == false ) { return false; }
        } else if ( o.fvi != NULL ) {
            o.fvi( o.v, i, el );
        } else if ( o.bvi != NULL ) {
            if ( o.bvi( o.v, i, el ) == false ) { return false; }
        }
        if ( errno ) { return false; }
    }
    return true;
}


double
arrayc_{{funcname}}__sum_to_double_by(
        ArrayC_{{typename}} const xs,
        double ( * const converter )( {{type}} x ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            converter != NULL );

    double sum = 0;
    ARRAYC_{{macroname}}__FOR_EACH( xs, x ) {
        sum += converter( *x );
    }
    return sum;
}


bool
arrayc_{{funcname}}__equal_by(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), eq != NULL );

    if ( xs.length != ys.length ) { return false; }
    if ( xs.e == ys.e ) { return true; }
    for ( size_t i = 0; i < xs.length; i++ ) {
        if ( !eq( xs.e[ i ], ys.e[ i ] ) ) {
            return false;
        }
    }
    return true;
}


bool
arrayc_{{funcname}}__has_prefix_by(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__equal_by(
               arrayc_{{funcname}}__take( xs, ys.length ), ys, eq );
}


bool
arrayc_{{funcname}}__has_suffix_by(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__equal_by(
               arrayc_{{funcname}}__take_end( xs, ys.length ), ys, eq );
}


bool
arrayc_{{funcname}}__has_infix_by(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return !( arrayc_{{funcname}}__infix_index_by( xs, ys, eq ).nothing );
}


Maybe_size
arrayc_{{funcname}}__infix_index_by(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    for ( size_t i = 0; i < xs.length; i++ ) {
        ArrayC_{{typename}} const xs_rest = arrayc_{{funcname}}__drop( xs, i );
        if ( arrayc_{{funcname}}__has_prefix_by( xs_rest, ys, eq ) ) {
            return ( Maybe_size ){ .value = i };
        }
    }
    return ( Maybe_size ){ .nothing = true };
}


Maybe_size
arrayc_{{funcname}}__last_infix_index_by(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    for ( size_t i = ys.length; i < xs.length; i++ ) {
        ArrayC_{{typename}} const xs_tail = arrayc_{{funcname}}__take_end(
                                                xs, i );
        if ( arrayc_{{funcname}}__has_prefix_by( xs_tail, ys, eq ) ) {
            return ( Maybe_size ){ .value = i };
        }
    }
    // Here, we've seen that all tails of `xs` beginning from `ys.length` down
    // to `1` do not start with `ys`. We now have to check that `xs` itself
    // does not begin with `ys`:
    if ( arrayc_{{funcname}}__has_prefix_by( xs, ys, eq ) ) {
        return ( Maybe_size ){ .value = 0 };
    } else {
        return ( Maybe_size ){ .nothing = true };
    }
}


size_t
arrayc_{{funcname}}__infix_count_by(
        ArrayC_{{typename}} xs,
        ArrayC_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            eq != NULL );

    size_t count = 0;
    Maybe_size mi;
    while ( mi = arrayc_{{funcname}}__infix_index_by( xs, ys, eq ),
            !mi.nothing ) {
        xs = arrayc_{{funcname}}__drop( xs, mi.value + 1 );
        count++;
    }
    return count;
}


bool
arrayc_{{funcname}}__elem_by(
        ArrayC_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), eq != NULL );

    return !( arrayc_{{funcname}}__elem_index_by( xs, y, eq ).nothing );
}


Maybe_size
arrayc_{{funcname}}__elem_index_by(
        ArrayC_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), eq != NULL );

    for ( size_t i = 0; i < xs.length; i++ ) {
        if ( eq( arrayc_{{funcname}}__get( xs, i ), y ) ) {
            return ( Maybe_size ){ .value = i };
        }
    }
    return ( Maybe_size ){ .nothing = true };
}


{{type}} const *
arrayc_{{funcname}}__elem_ptr_by(
        ArrayC_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), eq != NULL );

    Maybe_size const mi = arrayc_{{funcname}}__elem_index_by( xs, y, eq );
    return mi.nothing ? NULL : arrayc_{{funcname}}__getp( xs, mi.value );
}


Maybe_size
arrayc_{{funcname}}__elem_last_index_by(
        ArrayC_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), eq != NULL );

    for ( size_t _i = xs.length; _i > 0; _i-- ) {
        size_t i = _i - 1;
        if ( eq( arrayc_{{funcname}}__get( xs, i ), y ) ) {
            return ( Maybe_size ){ .value = i };
        }
    }
    return ( Maybe_size ){ .nothing = true };
}


{{type}} const *
arrayc_{{funcname}}__elem_last_ptr_by(
        ArrayC_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), eq != NULL );

    Maybe_size const mi = arrayc_{{funcname}}__elem_last_index_by( xs, y, eq );
    return mi.nothing ? NULL : arrayc_{{funcname}}__getp( xs, mi.value );
}


size_t
arrayc_{{funcname}}__elem_count_by(
        ArrayC_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), eq != NULL );

    size_t count = 0;
    for ( size_t i = 0; i < xs.length; i++ ) {
        if ( eq( xs.e[ i ], y ) ) {
            count++;
        }
    }
    return count;
}


ArrayM_{{typename}}
arrayc_{{funcname}}__replacedf(
        ArrayC_{{typename}} const xs,
        bool ( * const f )( {{type}} x ),
        {{type}} const repl )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), f != NULL );

    errno = 0;
    ArrayM_{{typename}} const new = arraym_{{funcname}}__copy_arrayc( xs );
    if ( errno ) { return ( ArrayM_{{typename}} ){ 0 }; }
    arraym_{{funcname}}__replacef( new, f, repl );
    return new;
}


ArrayM_{{typename}}
arrayc_{{funcname}}__replaced_by(
        ArrayC_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} el ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), eq != NULL );

    errno = 0;
    ArrayM_{{typename}} const new = arraym_{{funcname}}__copy_arrayc( xs );
    if ( errno ) { return ( ArrayM_{{typename}} ){ 0 }; }
    arraym_{{funcname}}__replace_by( new, el, repl, eq );
    return new;
}


ord
arrayc_{{funcname}}__compare_by(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ),
            cmp != NULL );

    if ( arrayc_{{funcname}}__same( xs, ys ) ) { return EQ; }
    for ( size_t i = 0; i < MIN( xs.length, ys.length ); i++ ) {
        ord const c = cmp( xs.e[ i ], ys.e[ i ] );
        if ( c != EQ ) { return c; }
    }
    // Here, all elements up to the minimum length are equal, so:
    return size__compare( xs.length, ys.length );
}


bool
arrayc_{{funcname}}__is_ascending_by(
        ArrayC_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), cmp != NULL );

    if ( xs.length >= 2 ) {
        for ( size_t i = 0; i < xs.length - 1; i++ ) {
            if ( cmp( xs.e[ i ], xs.e[ i + 1 ] ) == GT ) {
                return false;
            }
        }
    }
    return true;
}


bool
arrayc_{{funcname}}__is_strictly_ascending_by(
        ArrayC_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), cmp != NULL );

    if ( xs.length >= 2 ) {
        for ( size_t i = 0; i < xs.length - 1; i++ ) {
            if ( cmp( xs.e[ i ], xs.e[ i + 1 ] ) != LT ) {
                return false;
            }
        }
    }
    return true;
}


bool
arrayc_{{funcname}}__is_descending_by(
        ArrayC_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), cmp != NULL );

    if ( xs.length >= 2 ) {
        for ( size_t i = 0; i < xs.length - 1; i++ ) {
            if ( cmp( xs.e[ i ], xs.e[ i + 1 ] ) == LT ) {
                return false;
            }
        }
    }
    return true;
}


bool
arrayc_{{funcname}}__is_strictly_descending_by(
        ArrayC_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), cmp != NULL );

    if ( xs.length >= 2 ) {
        for ( size_t i = 0; i < xs.length - 1; i++ ) {
            if ( cmp( xs.e[ i ], xs.e[ i + 1 ] ) != GT ) {
                return false;
            }
        }
    }
    return true;
}


{{type}}
arrayc_{{funcname}}__minimum_by(
        ArrayC_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), xs.length >= 1, cmp != NULL );

    {{type}} min = xs.e[ 0 ];
    for ( size_t i = 1; i < xs.length; i++ ) {
        {{type}} const x = xs.e[ i ];
        if ( cmp( x, min ) == LT ) {
            min = x;
        }
    }
    return min;
}


{{type}}
arrayc_{{funcname}}__maximum_by(
        ArrayC_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ), xs.length >= 1, cmp != NULL );

    {{type}} max = xs.e[ 0 ];
    for ( size_t i = 1; i < xs.length; i++ ) {
        {{type}} const x = xs.e[ i ];
        if ( cmp( x, max ) == GT ) {
            max = x;
        }
    }
    return max;
}




bool
arraym_{{funcname}}__is_valid(
        ArrayM_{{typename}} const xs )
{
    return IMPLIES( xs.e == NULL, xs.length == 0 );
}


ArrayM_{{typename}}
arraym_{{funcname}}__new(
        {{type}} const * const elements,
        size_t const length )
{
    return arraym_{{funcname}}__copy_arrayc(
               arrayc_{{funcname}}__new( elements, length ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__new_view(
        {{type}} * const elements,
        size_t const length )
{
    if ( elements == NULL ) {
        return ( ArrayM_{{typename}} ){ .e = NULL, .length = 0 };
    } else {
        return ( ArrayM_{{typename}} ){ .e = elements, .length = length };
    }
}


ArrayM_{{typename}}
arraym_{{funcname}}__new_empty(
        void )
{
    return arraym_{{funcname}}__new( NULL, 0 );
}


ArrayM_{{typename}}
arraym_{{funcname}}__new_alloc(
        size_t const length )
{
    ArrayM_{{typename}} new = { 0 };
    arraym_{{funcname}}__realloc( &new, length );
    return new;
}


ArrayM_{{typename}}
arraym_{{funcname}}__new_calloc(
        size_t const length )
{
    errno = 0;
    ArrayM_{{typename}} new = arraym_{{funcname}}__new_alloc( length );
    if ( errno ) { return new; }
    arraym_{{funcname}}__memzero( new );
    return new;
}


void
arraym_{{funcname}}__free(
        ArrayM_{{typename}} * const xs )
{
    ASSERT( xs != NULL, arraym_{{funcname}}__is_valid( *xs ) );

    arraym_{{funcname}}__realloc( xs, 0 );
}


void
arraym_{{funcname}}__free_with(
        ArrayM_{{typename}} * const xs,
        void ( * const freer )( {{type}} * x ) )
{
    ASSERT( xs != NULL, arraym_{{funcname}}__is_valid( *xs ) );

    arraym_{{funcname}}__eachp( *xs, .f = freer );
    arraym_{{funcname}}__free( xs );
}


void
arraym_{{funcname}}__realloc(
        ArrayM_{{typename}} * const xs,
        size_t const new_length )
{
    ASSERT( xs != NULL, arraym_{{funcname}}__is_valid( *xs ) );

    arraym_{{funcname}}__realloc_with( xs, new_length, NULL );
}


void
arraym_{{funcname}}__realloc_with(
        ArrayM_{{typename}} * const xs,
        size_t const new_length,
        void ( * const freer )( {{type}} * lost_el ) )
{
    ASSERT( xs != NULL, arraym_{{funcname}}__is_valid( *xs ) );

    errno = 0;
    arraym_{{funcname}}__eachp( arraym_{{funcname}}__drop( *xs, new_length ),
                                .f = freer );
    if ( errno ) { return; }
    if ( new_length != xs->length ) {
        {{type}} * const new_e = reallocn( xs->e, new_length,
                                           sizeof ( {{type}} ) );
        if ( errno ) { return; }
        *xs = ( ArrayM_{{typename}} ){ .e = new_e, .length = new_length };
    }
}


void
arraym_{{funcname}}__reallocz(
        ArrayM_{{typename}} * const xs,
        size_t const new_length )
{
    ASSERT( xs != NULL, arraym_{{funcname}}__is_valid( *xs ) );

    arraym_{{funcname}}__reallocz_with( xs, new_length, NULL );
}


void
arraym_{{funcname}}__reallocz_with(
        ArrayM_{{typename}} * const xs,
        size_t const new_length,
        void ( * const freer )( {{type}} * lost_el ) )
{
    ASSERT( xs != NULL, arraym_{{funcname}}__is_valid( *xs ) );

    errno = 0;
    arraym_{{funcname}}__eachp( arraym_{{funcname}}__drop( *xs, new_length ),
                                .f = freer );
    if ( errno ) { return; }
    if ( new_length != xs->length ) {
        {{type}} * const new_e = reallocn( xs->e, new_length,
                                           sizeof ( {{type}} ) );
        if ( errno ) { return; }
        if ( new_length > xs->length ) {
            memset( new_e + xs->length, 0,
                    ( new_length - xs->length ) * sizeof ( {{type}} ) );
        }
        *xs = ( ArrayM_{{typename}} ){ .e = new_e, .length = new_length };
    }
}


void
arraym_{{funcname}}__memcpy_from(
        ArrayM_{{typename}} const to,
        void const * const from,
        size_t const from_size )
{
    ASSERT( arraym_{{funcname}}__is_valid( to ) );

    if ( to.e != NULL && from != NULL ) {
        memcpy( to.e, from,
                MIN( from_size, arraym_{{funcname}}__size( to ) ) );
    }
}


void
arraym_{{funcname}}__memcpy_to(
        ArrayM_{{typename}} const from,
        void * const to,
        size_t const to_size )
{
    ASSERT( arraym_{{funcname}}__is_valid( from ) );

    arrayc_{{funcname}}__memcpy_to(
        arrayc_{{funcname}}__view_arraym( from ), to, to_size );
}


void
arraym_{{funcname}}__copy_into_arraym(
        ArrayM_{{typename}} const from,
        ArrayM_{{typename}} const to )
{
    ASSERT( arraym_{{funcname}}__is_valid( from ),
            arraym_{{funcname}}__is_valid( to ) );

    arraym_{{funcname}}__copy_into_arraym_with( from, to, NULL );
}


void
arraym_{{funcname}}__copy_into_arraym_with(
        ArrayM_{{typename}} const from,
        ArrayM_{{typename}} const to,
        void ( * const copier )( {{type}} * to_el, {{type}} from_el ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( from ),
            arraym_{{funcname}}__is_valid( to ) );

    arrayc_{{funcname}}__copy_into_arraym_with(
        arrayc_{{funcname}}__view_arraym( from ), to, copier );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_arrayc(
        ArrayC_{{typename}} const from )
{
    ASSERT( arrayc_{{funcname}}__is_valid( from ) );

    return arraym_{{funcname}}__copy_arrayc_with( from, NULL );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_arrayc_with(
        ArrayC_{{typename}} const from,
        void ( * const copier )( {{type}} * new_el, {{type}} from_el ) )
{
    ASSERT( arrayc_{{funcname}}__is_valid( from ) );

    ArrayM_{{typename}} const new =
            arraym_{{funcname}}__new_alloc( from.length );
    if ( errno ) { return new; }
    arrayc_{{funcname}}__copy_into_arraym_with( from, new, copier );
    return new;
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_arraym(
        ArrayM_{{typename}} const from )
{
    ASSERT( arraym_{{funcname}}__is_valid( from ) );

    return arraym_{{funcname}}__copy_arraym_with( from, NULL );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_arraym_with(
        ArrayM_{{typename}} const from,
        void ( * const copier )( {{type}} * new_el, {{type}} from_el ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( from ) );

    return arraym_{{funcname}}__copy_arrayc_with(
               arrayc_{{funcname}}__view_arraym( from ), copier );
}


void
arraym_{{funcname}}__copy_arrayc_into(
        ArrayM_{{typename}} * const to,
        ArrayC_{{typename}} const from )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ),
            arrayc_{{funcname}}__is_valid( from ) );

    arraym_{{funcname}}__copy_arrayc_into_with( to, from, NULL, NULL );
}


void
arraym_{{funcname}}__copy_arrayc_into_with(
        ArrayM_{{typename}} * const to,
        ArrayC_{{typename}} const from,
        void ( * const copier )( {{type}} * to_el, {{type}} from_el ),
        void ( * const freer )( {{type}} * unused_to_el ) )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ),
            arrayc_{{funcname}}__is_valid( from ) );

    arraym_{{funcname}}__realloc_with( to, from.length, freer );
    if ( errno ) { return; }
    arrayc_{{funcname}}__copy_into_arraym_with( from, *to, copier );
}


void
arraym_{{funcname}}__copy_arraym_into(
        ArrayM_{{typename}} * const to,
        ArrayM_{{typename}} const from )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ),
            arraym_{{funcname}}__is_valid( from ) );

    arraym_{{funcname}}__copy_arraym_into_with( to, from, NULL, NULL );
}


void
arraym_{{funcname}}__copy_arraym_into_with(
        ArrayM_{{typename}} * const to,
        ArrayM_{{typename}} const from,
        void ( * const copier )( {{type}} * to_el, {{type}} from_el ),
        void ( * const freer )( {{type}} * unused_to ) )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ),
            arraym_{{funcname}}__is_valid( from ) );

    arraym_{{funcname}}__copy_arrayc_into_with(
            to, arrayc_{{funcname}}__view_arraym( from ), copier, freer );
}


ArrayM_{{typename}}
arraym_{{funcname}}__id(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return xs;
}


{{type}} *
arraym_{{funcname}}__elements(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return xs.e;
}


size_t
arraym_{{funcname}}__length(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return xs.length;
}


size_t
arraym_{{funcname}}__size(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            size__can_mul( xs.length, sizeof ( {{type}} ) ) );

    return xs.length * sizeof ( {{type}} );
}


bool
arraym_{{funcname}}__is_empty(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return xs.length == 0;
}


bool
arraym_{{funcname}}__isnt_empty(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return !arraym_{{funcname}}__is_empty( xs );
}


bool
arraym_{{funcname}}__is_length_1(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return xs.length == 1;
}


bool
arraym_{{funcname}}__same(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ) );

    return arrayc_{{funcname}}__same(
               arrayc_{{funcname}}__view_arraym( xs ),
               arrayc_{{funcname}}__view_arraym( ys ) );
}


{{type}}
arraym_{{funcname}}__get(
        ArrayM_{{typename}} const xs,
        size_t const index )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), index < xs.length );

    {{type}} * const p = arraym_{{funcname}}__getp( xs, index );
    ASSERT( p != NULL );
    return *p;
}


{{type}} *
arraym_{{funcname}}__getp(
        ArrayM_{{typename}} const xs,
        size_t const index )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return ( index < xs.length ) ? ( xs.e + index ) : ( NULL );
}


Maybe_{{typename}}
arraym_{{funcname}}__getm(
        ArrayM_{{typename}} const xs,
        size_t const index )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return maybe_{{funcname}}__from_ptr(
               arraym_{{funcname}}__getp( xs, index ) );
}


{{type}}
arraym_{{funcname}}__set(
        ArrayM_{{typename}} const xs,
        size_t const index,
        {{type}} const value )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), index < xs.length );

    {{type}} * const p = arraym_{{funcname}}__getp( xs, index );
    ASSERT( p != NULL );
    {{type}} const old = *p;
    *p = value;
    return old;
}


Maybe_{{typename}}
arraym_{{funcname}}__setm(
        ArrayM_{{typename}} const xs,
        size_t const index,
        {{type}} const value )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return ( index < xs.length )
           ? ( Maybe_{{typename}} ){
                 .value = arraym_{{funcname}}__set( xs, index, value ) }
           : ( Maybe_{{typename}} ){ .nothing = true };
}


void
arraym_{{funcname}}__set_all(
        ArrayM_{{typename}} const xs,
        {{type}} const value )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    for ( size_t i = 0; i < xs.length; i++ ) {
        xs.e[ i ] = value;
    }
}


{{type}}
arraym_{{funcname}}__set_first(
        ArrayM_{{typename}} const xs,
        {{type}} const value )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__isnt_empty( xs ) );

    return arraym_{{funcname}}__set( xs, 0, value );
}


{{type}}
arraym_{{funcname}}__set_last(
        ArrayM_{{typename}} const xs,
        {{type}} const value )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__isnt_empty( xs ) );

    return arraym_{{funcname}}__set( xs, xs.length - 1, value );
}


void
arraym_{{funcname}}__swap(
        ArrayM_{{typename}} const xs,
        size_t const i,
        size_t const j )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            i < xs.length, j < xs.length );

    {{type}} const i_el = xs.e[ i ];
    xs.e[ i ] = xs.e[ j ];
    xs.e[ j ] = i_el;
}


void
arraym_{{funcname}}__swap_sequence(
        ArrayM_{{typename}} const xs,
        size_t const n,
        size_t const start1,
        size_t const start2 )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            size__add( start1, n ) <= xs.length,
            size__add( start2, n ) <= xs.length );

    for ( size_t i = 0; i < n; i++ ) {
        arraym_{{funcname}}__swap( xs, start1 + i, start2 + i );
    }
}


void
arraym_{{funcname}}__memset(
        ArrayM_{{typename}} const xs,
        uchar const byte )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    if ( xs.e != NULL ) {
        memset( xs.e, byte, arraym_{{funcname}}__size( xs ) );
    }
}


void
arraym_{{funcname}}__memzero(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    arraym_{{funcname}}__memset( xs, 0 );
}


{{type}}
arraym_{{funcname}}__first(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__isnt_empty( xs ) );

    return *( arraym_{{funcname}}__firstp( xs ) );
}


{{type}} *
arraym_{{funcname}}__firstp(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__getp( xs, 0 );
}


Maybe_{{typename}}
arraym_{{funcname}}__firstm(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return maybe_{{funcname}}__from_ptr( arraym_{{funcname}}__firstp( xs ) );
}


{{type}}
arraym_{{funcname}}__middle(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__isnt_empty( xs ) );

    return *( arraym_{{funcname}}__middlep( xs ) );
}


{{type}} *
arraym_{{funcname}}__middlep(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__getp( xs, xs.length / 2 );
}


Maybe_{{typename}}
arraym_{{funcname}}__middlem(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return maybe_{{funcname}}__from_ptr( arraym_{{funcname}}__middlep( xs ) );
}


{{type}}
arraym_{{funcname}}__last(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__isnt_empty( xs ) );

    return *( arraym_{{funcname}}__lastp( xs ) );
}


{{type}} *
arraym_{{funcname}}__lastp(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__getp( xs, xs.length - 1 );
}


Maybe_{{typename}}
arraym_{{funcname}}__lastm(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return maybe_{{funcname}}__from_ptr( arraym_{{funcname}}__lastp( xs ) );
}


size_t
arraym_{{funcname}}__count(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__count(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


size_t
arraym_{{funcname}}__count_first(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__count_first(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


size_t
arraym_{{funcname}}__count_last(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__count_last(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


ArrayM_{{typename}}
arraym_{{funcname}}__take(
        ArrayM_{{typename}} const xs,
        size_t const n )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return xs;
    } else {
        return ( ArrayM_{{typename}} ){
                   .e      = xs.e,
                   .length = n };
    }
}


ArrayM_{{typename}}
arraym_{{funcname}}__drop(
        ArrayM_{{typename}} const xs,
        size_t const n )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return ( ArrayM_{{typename}} ){ .e = NULL, .length = 0 };
    } else {
        return ( ArrayM_{{typename}} ){
                   .e      = xs.e + n,
                   .length = xs.length - n };
    }
}


ArrayM_{{typename}}
arraym_{{funcname}}__take_end(
        ArrayM_{{typename}} const xs,
        size_t const n )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return xs;
    } else {
        return arraym_{{funcname}}__drop( xs, xs.length - n );
    }
}


ArrayM_{{typename}}
arraym_{{funcname}}__drop_end(
        ArrayM_{{typename}} const xs,
        size_t const n )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return ( ArrayM_{{typename}} ){ .e = NULL, .length = 0 };
    } else {
        return arraym_{{funcname}}__take( xs, xs.length - n );
    }
}


ArrayM_{{typename}}
arraym_{{funcname}}__take_while(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arraym_{{funcname}}__take(
               xs,
               arraym_{{funcname}}__count_first( xs, f ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__take_end_while(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arraym_{{funcname}}__take_end(
               xs,
               arraym_{{funcname}}__count_last( xs, f ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__drop_while(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arraym_{{funcname}}__drop(
               xs,
               arraym_{{funcname}}__count_first( xs, f ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__drop_end_while(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arraym_{{funcname}}__drop_end(
               xs,
               arraym_{{funcname}}__count_last( xs, f ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__slice(
        ArrayM_{{typename}} const xs,
        size_t const start,
        size_t const stop )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__drop(
               arraym_{{funcname}}__take( xs, stop ),
               start );
}


ArrayM_{{typename}}
arraym_{{funcname}}__slice_s(
        ArrayM_{{typename}} const xs,
        intmax_t const start,
        intmax_t const stop )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__slice(
               xs,
               normalize_index( start, xs.length ),
               normalize_index( stop, xs.length ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__left_half(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__take( xs, xs.length / 2 );
}


ArrayM_{{typename}}
arraym_{{funcname}}__right_half(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__drop( xs, xs.length / 2 );
}


Maybe_size
arraym_{{funcname}}__find(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__find(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


Maybe_size
arraym_{{funcname}}__find_not(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__find_not(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


Maybe_size
arraym_{{funcname}}__find_last(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__find_last(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


Maybe_size
arraym_{{funcname}}__find_last_not(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__find_last_not(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


{{type}} *
arraym_{{funcname}}__findp(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = arraym_{{funcname}}__find( xs, f );
    return mi.nothing ? NULL : ( xs.e + mi.value );
}


{{type}} *
arraym_{{funcname}}__findp_not(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = arraym_{{funcname}}__find_not( xs, f );
    return mi.nothing ? NULL : ( xs.e + mi.value );
}


{{type}} *
arraym_{{funcname}}__findp_last(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = arraym_{{funcname}}__find_last( xs, f );
    return mi.nothing ? NULL : ( xs.e + mi.value );
}


{{type}} *
arraym_{{funcname}}__findp_last_not(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = arraym_{{funcname}}__find_last_not( xs, f );
    return mi.nothing ? NULL : ( xs.e + mi.value );
}


Maybe_{{typename}}
arraym_{{funcname}}__findm(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__findm(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


Maybe_{{typename}}
arraym_{{funcname}}__findm_not(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__findm_not(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


Maybe_{{typename}}
arraym_{{funcname}}__findm_last(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__findm_last(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


Maybe_{{typename}}
arraym_{{funcname}}__findm_last_not(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__findm_last_not(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


bool
arraym_{{funcname}}__any(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__any(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


bool
arraym_{{funcname}}__all(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__all(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


bool
arraym_{{funcname}}__only_one(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__only_one(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


bool
arraym_{{funcname}}__all_but_one(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__all_but_one(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


{{type}}
arraym_{{funcname}}__foldl(
        ArrayM_{{typename}} const xs,
        {{type}} const init,
        {{type}} ( * const f )( {{type}} acc, {{type}} x ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__foldl(
               arrayc_{{funcname}}__view_arraym( xs ), init, f );
}


{{type}}
arraym_{{funcname}}__foldl1(
        ArrayM_{{typename}} const xs,
        {{type}} ( * const f )( {{type}} acc, {{type}} x ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), xs.length > 0, f != NULL );

    return arrayc_{{funcname}}__foldl1(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


{{type}}
arraym_{{funcname}}__foldr(
        ArrayM_{{typename}} const xs,
        {{type}} const init,
        {{type}} ( * const f )( {{type}} x, {{type}} acc ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__foldr(
               arrayc_{{funcname}}__view_arraym( xs ), init, f );
}


{{type}}
arraym_{{funcname}}__foldr1(
        ArrayM_{{typename}} const xs,
        {{type}} ( * const f )( {{type}} x, {{type}} acc ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), xs.length > 0, f != NULL );

    return arrayc_{{funcname}}__foldr1(
               arrayc_{{funcname}}__view_arraym( xs ), f );
}


{{type}} *
arraym_{{funcname}}__pick(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} const * pick, {{type}} x ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} * pick = NULL;
    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} * const el = arraym_{{funcname}}__getp( xs, i );
        if ( f( pick, *el ) ) {
            pick = el;
        }
    }
    return pick;
}


{{type}} *
arraym_{{funcname}}__pickv(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} const * pick, {{type}} x, void * ptr ),
        void * const ptr )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} * pick = NULL;
    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} * const el = arraym_{{funcname}}__getp( xs, i );
        if ( f( pick, *el, ptr ) ) {
            pick = el;
        }
    }
    return pick;
}


bool
arraym_{{funcname}}__each_(
        ArrayM_{{typename}} const xs,
        struct arrayc_{{funcname}}__each__options const o )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__each_(
               arrayc_{{funcname}}__view_arraym( xs ), o );
}


bool
arraym_{{funcname}}__eachp_(
        ArrayM_{{typename}} const xs,
        struct arraym_{{funcname}}__eachp__options const o )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} * const el = arraym_{{funcname}}__getp( xs, i );
        if ( ( o.where != NULL && !o.where( *el ) )
          || ( o.where_not != NULL && o.where_not( *el ) ) ) {
            continue;
        }
        errno = 0;
        if ( o.f != NULL ) {
            o.f( el );
        } else if ( o.b != NULL ) {
            if ( o.b( el ) == false ) { return false; }
        } else if ( o.fi != NULL ) {
            o.fi( i, el );
        } else if ( o.bi != NULL ) {
            if ( o.bi( i, el ) == false ) { return false; }
        } else if ( o.fv != NULL ) {
            o.fv( o.v, el );
        } else if ( o.bv != NULL ) {
            if ( o.bv( o.v, el ) == false ) { return false; }
        } else if ( o.fvi != NULL ) {
            o.fvi( o.v, i, el );
        } else if ( o.bvi != NULL ) {
            if ( o.bvi( o.v, i, el ) == false ) { return false; }
        }
        if ( errno ) { return false; }
    }
    return true;
}


double
arraym_{{funcname}}__sum_to_double_by(
        ArrayM_{{typename}} const xs,
        double ( * const converter )( {{type}} x ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            converter != NULL );

    return arrayc_{{funcname}}__sum_to_double_by(
               arrayc_{{funcname}}__view_arraym( xs ), converter );
}


bool
arraym_{{funcname}}__equal_by(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), eq != NULL );

    return arrayc_{{funcname}}__equal_by(
               arrayc_{{funcname}}__view_arraym( xs ),
               arrayc_{{funcname}}__view_arraym( ys ),
               eq );
}


bool
arraym_{{funcname}}__has_prefix_by(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__has_prefix_by(
               arrayc_{{funcname}}__view_arraym( xs ),
               arrayc_{{funcname}}__view_arraym( ys ),
               eq );
}


bool
arraym_{{funcname}}__has_suffix_by(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__has_suffix_by(
               arrayc_{{funcname}}__view_arraym( xs ),
               arrayc_{{funcname}}__view_arraym( ys ),
               eq );
}


bool
arraym_{{funcname}}__has_infix_by(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__has_infix_by(
               arrayc_{{funcname}}__view_arraym( xs ),
               arrayc_{{funcname}}__view_arraym( ys ),
               eq );
}


Maybe_size
arraym_{{funcname}}__infix_index_by(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__infix_index_by(
               arrayc_{{funcname}}__view_arraym( xs ),
               arrayc_{{funcname}}__view_arraym( ys ),
               eq );
}


Maybe_size
arraym_{{funcname}}__last_infix_index_by(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__last_infix_index_by(
               arrayc_{{funcname}}__view_arraym( xs ),
               arrayc_{{funcname}}__view_arraym( ys ),
               eq );
}


size_t
arraym_{{funcname}}__infix_count_by(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return arrayc_{{funcname}}__infix_count_by(
               arrayc_{{funcname}}__view_arraym( xs ),
               arrayc_{{funcname}}__view_arraym( ys ),
               eq );
}


bool
arraym_{{funcname}}__elem_by(
        ArrayM_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), eq != NULL );

    return arrayc_{{funcname}}__elem_by(
               arrayc_{{funcname}}__view_arraym( xs ), y, eq );
}


Maybe_size
arraym_{{funcname}}__elem_index_by(
        ArrayM_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), eq != NULL );

    return arrayc_{{funcname}}__elem_index_by(
               arrayc_{{funcname}}__view_arraym( xs ), y, eq );
}


{{type}} *
arraym_{{funcname}}__elem_ptr_by(
        ArrayM_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), eq != NULL );

    Maybe_size const mi = arraym_{{funcname}}__elem_index_by( xs, y, eq );
    return mi.nothing ? NULL : arraym_{{funcname}}__getp( xs, mi.value );
}


Maybe_size
arraym_{{funcname}}__elem_last_index_by(
        ArrayM_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), eq != NULL );

    return arrayc_{{funcname}}__elem_last_index_by(
               arrayc_{{funcname}}__view_arraym( xs ), y, eq );
}


{{type}} *
arraym_{{funcname}}__elem_last_ptr_by(
        ArrayM_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), eq != NULL );

    Maybe_size const mi = arraym_{{funcname}}__elem_last_index_by( xs, y, eq );
    return mi.nothing ? NULL : arraym_{{funcname}}__getp( xs, mi.value );
}


size_t
arraym_{{funcname}}__elem_count_by(
        ArrayM_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), eq != NULL );

    return arrayc_{{funcname}}__elem_count_by(
               arrayc_{{funcname}}__view_arraym( xs ), y, eq );
}


void
arraym_{{funcname}}__replacef(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} x ),
        {{type}} const repl )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} * const x = xs.e + i;
        if ( f( *x ) == true ) {
            *x = repl;
        }
    }
}


ArrayM_{{typename}}
arraym_{{funcname}}__replacedf(
        ArrayM_{{typename}} const xs,
        bool ( * const f )( {{type}} x ),
        {{type}} const repl )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), f != NULL );

    return arrayc_{{funcname}}__replacedf(
               arrayc_{{funcname}}__view_arraym( xs ), f, repl );
}


void
arraym_{{funcname}}__replace_by(
        ArrayM_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} el ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), eq != NULL );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} * const x = xs.e + i;
        if ( eq( *x, el ) == true ) {
            *x = repl;
        }
    }
}


ArrayM_{{typename}}
arraym_{{funcname}}__replaced_by(
        ArrayM_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} el ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), eq != NULL );

    return arrayc_{{funcname}}__replaced_by(
               arrayc_{{funcname}}__view_arraym( xs ), el, repl, eq );
}


ord
arraym_{{funcname}}__compare_by(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ),
            cmp != NULL );

    return arrayc_{{funcname}}__compare_by(
               arrayc_{{funcname}}__view_arraym( xs ),
               arrayc_{{funcname}}__view_arraym( ys ),
               cmp );
}


bool
arraym_{{funcname}}__is_ascending_by(
        ArrayM_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), cmp != NULL );

    return arrayc_{{funcname}}__is_ascending_by(
               arrayc_{{funcname}}__view_arraym( xs ), cmp );
}


bool
arraym_{{funcname}}__is_strictly_ascending_by(
        ArrayM_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), cmp != NULL );

    return arrayc_{{funcname}}__is_strictly_ascending_by(
               arrayc_{{funcname}}__view_arraym( xs ), cmp );
}


bool
arraym_{{funcname}}__is_descending_by(
        ArrayM_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), cmp != NULL );

    return arrayc_{{funcname}}__is_descending_by(
               arrayc_{{funcname}}__view_arraym( xs ), cmp );
}


bool
arraym_{{funcname}}__is_strictly_descending_by(
        ArrayM_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), cmp != NULL );

    return arrayc_{{funcname}}__is_strictly_descending_by(
               arrayc_{{funcname}}__view_arraym( xs ), cmp );
}


{{type}}
arraym_{{funcname}}__minimum_by(
        ArrayM_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), xs.length >= 1, cmp != NULL );

    return arrayc_{{funcname}}__minimum_by(
               arrayc_{{funcname}}__view_arraym( xs ), cmp );
}


{{type}}
arraym_{{funcname}}__maximum_by(
        ArrayM_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), xs.length >= 1, cmp != NULL );

    return arrayc_{{funcname}}__maximum_by(
               arrayc_{{funcname}}__view_arraym( xs ), cmp );
}


static
void
swap_if_gt(
        ArrayM_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ),
        size_t const i,
        size_t const j )
{
    if ( cmp( xs.e[ i ], xs.e[ j ] ) == GT ) {
        arraym_{{funcname}}__swap( xs, i, j );
    }
}


typedef struct size_pair {
    size_t left;
    size_t right;
} SizePair;


static
SizePair
quicksort_partition(
        ArrayM_{{typename}} const xs,
        {{type}} const pivot,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), cmp != NULL );

    if ( xs.length == 0 ) { return ( SizePair ){ 0, 0 }; }

    size_t eql = 0;
    size_t lt = 0;
    size_t gt = xs.length - 1;
    bool gt_neg_1 = false;
    size_t eqr = xs.length - 1;

    while ( true ) {

        // Invariant of ordering, with respect to the pivot, within `xs`:
        //      _______________________________________
        //     | == |     <     |  ?  |     >     | == |
        //      -----^-----------^---^-----------^-----
        //          eql         lt   gt         eqr

        // Note that we must perform awkward checks for the bound values of
        // `size_t` on `lt` and `gt` to avoid overflow and underflow.

        // Increment `lt` up to the index of the first element greater
        // than the pivot. Move any elements equal to the pivot to the
        // left-hand equals section.
        for ( ; lt <= gt; lt++ ) {
            ord const c = cmp( xs.e[ lt ], pivot );
            if ( c == GT ) { break; }
            if ( c == EQ ) {
                arraym_{{funcname}}__swap( xs, lt, eql );
                eql++;
            }
            if ( lt == SIZE_MAX ) { break; }
        }

        // Decrement `gt` down to the index of the first element less
        // than the pivot. Move any elements equal to the pivot to the
        // right-equals section.
        for ( ; gt >= lt; gt-- ) {
            ord const c = cmp( xs.e[ gt ], pivot );
            if ( c == LT ) { break; }
            if ( c == EQ ) {
                arraym_{{funcname}}__swap( xs, gt, eqr );
                eqr--;
            }
            if ( gt == 0 ) { gt_neg_1 = true; break; }
        }

        if ( lt > gt || gt_neg_1 == true ) {
            // Then there are no more unsorted elements.
            break;
        }

        // Here, `xs[ lt ] > pivot` and `xs[ gt ] < pivot`, so swap each
        // of those into the other section, and move onto the next
        // elements.
        arraym_{{funcname}}__swap( xs, lt, gt );
        // `lt` can't be `SIZE_MAX` here because `gt <= SIZE_MAX - 1`, so if
        // `lt == SIZE_MAX`, the loop will have been broken at `lt > gt`.
        lt++;
        if ( gt == 0 ) { gt_neg_1 = true; break; }
        gt--;

    }

    // `xs` is now ordered, with respect to the pivot, as such:
    //      _____________________________________
    //     | == |      <      |      >      | == |
    //      -----^-----------^-^-----------^-----
    //          eql         gt lt         eqr

    // The size of the less-than section:
    size_t const nlt = lt - eql;
    // The size of the greater-than section:
    size_t const ngt = eqr - gt + gt_neg_1;

    // Swap the left-equals section with the right-hand side of the
    // less-than section:
    size_t const nleft = MIN( eql, nlt );
    ASSERT( nleft <= lt );
    arraym_{{funcname}}__swap_sequence( xs, nleft, 0, lt - nleft );

    // Swap the right-equals section with the left-hand side of the
    // greater-than section:
    size_t const nright = MIN( xs.length - 1 - eqr, ngt );
    ASSERT( nright <= xs.length );
    arraym_{{funcname}}__swap_sequence( xs, nright, lt, xs.length - nright );

    // Above, we take the minimum of the section sizes so that we only move
    // the smallest section (e.g. move the less-than section if it's smaller
    // than the left-equals section).

    // `xs` is now ordered, with respect to the pivot, as such:
    //      ______________________________________
    //     |      <      |    ==    |      >      |
    //      --------------------------------------
    //     <---- nlt ---->          <---- ngt ---->

    // Return the sizes of the less-than and greater-than sections:
    return ( SizePair ){ .left = nlt, .right = ngt };
}


void
arraym_{{funcname}}__quicksort_by(
        ArrayM_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), cmp != NULL );

    {{type}} pivot;
    SizePair p;
    switch ( xs.length ) {
    case 0: case 1:
        break; // Already sorted
    // Optimizations for small `n` using sorting networks generated via:
    // <http://pages.ripco.net/~jgamble/nw.html>
    case 2:
        swap_if_gt( xs, cmp,  0, 1 );
        break;
    case 3:
        swap_if_gt( xs, cmp,  1, 2 );
        swap_if_gt( xs, cmp,  0, 2 );
        swap_if_gt( xs, cmp,  0, 1 );
        break;
    case 4:
        swap_if_gt( xs, cmp,  0, 1 );
        swap_if_gt( xs, cmp,  2, 3 );
        swap_if_gt( xs, cmp,  0, 2 );
        swap_if_gt( xs, cmp,  1, 3 );
        swap_if_gt( xs, cmp,  1, 2 );
        break;
    default:
        pivot = arraym_{{funcname}}__middle( xs );
        p = quicksort_partition( xs, pivot, cmp );
        // Sort the less-than section:
        arraym_{{funcname}}__quicksort_by(
                arraym_{{funcname}}__take( xs, p.left ), cmp );
        // Sort the greater-than section:
        arraym_{{funcname}}__quicksort_by(
                arraym_{{funcname}}__take_end( xs, p.right ), cmp );
        break;
    }
}


ArrayM_{{typename}}
arraym_{{funcname}}__quicksorted_by(
        ArrayM_{{typename}} const xs,
        ord ( * const cmp )( {{type}}, {{type}} ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ), cmp != NULL );

    ArrayM_{{typename}} const new = arraym_{{funcname}}__copy_arraym( xs );
    if ( errno ) { return new; }
    arraym_{{funcname}}__quicksort_by( new, cmp );
    return new;
}



{% if 'EQ' in typeclasses %}


static
bool
equalf(
        {{type}} const x,
        {{type}} const y )
{
    // `__equal()` might be defined as a type-generic macro:
    return {{funcname}}__equal( x, y );
}


bool
arrayc_{{funcname}}__equal(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ) );

    return arrayc_{{funcname}}__equal_by( xs, ys, equalf );
}


bool
arrayc_{{funcname}}__not_equal(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ) );

    return !arrayc_{{funcname}}__equal( xs, ys );
}


bool
arrayc_{{funcname}}__first_is(
        ArrayC_{{typename}} const xs,
        {{type}} const e )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    {{type}} const * const firstp = arrayc_{{funcname}}__firstp( xs );
    return firstp != NULL && {{funcname}}__equal( e, *firstp );
}


bool
arrayc_{{funcname}}__last_is(
        ArrayC_{{typename}} const xs,
        {{type}} const e )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    {{type}} const * const lastp = arrayc_{{funcname}}__lastp( xs );
    return lastp != NULL && {{funcname}}__equal( e, *lastp );
}


bool
arrayc_{{funcname}}__has_prefix(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ) );

    return arrayc_{{funcname}}__has_prefix_by( xs, ys, equalf );
}


bool
arrayc_{{funcname}}__has_suffix(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ) );

    return arrayc_{{funcname}}__has_suffix_by( xs, ys, equalf );
}


bool
arrayc_{{funcname}}__has_infix(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ) );

    return arrayc_{{funcname}}__has_infix_by( xs, ys, equalf );
}


Maybe_size
arrayc_{{funcname}}__infix_index(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ) );

    return arrayc_{{funcname}}__infix_index_by( xs, ys, equalf );
}


Maybe_size
arrayc_{{funcname}}__last_infix_index(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ) );

    return arrayc_{{funcname}}__last_infix_index_by( xs, ys, equalf );
}


bool
arrayc_{{funcname}}__elem(
        ArrayC_{{typename}} const xs,
        {{type}} const x )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__elem_by( xs, x, equalf );
}


Maybe_size
arrayc_{{funcname}}__elem_index(
        ArrayC_{{typename}} const xs,
        {{type}} const x )
{
    return arrayc_{{funcname}}__elem_index_by( xs, x, equalf );
}


{{type}} const *
arrayc_{{funcname}}__elem_ptr(
        ArrayC_{{typename}} const xs,
        {{type}} const x )
{
    return arrayc_{{funcname}}__elem_ptr_by( xs, x, equalf );
}


Maybe_size
arrayc_{{funcname}}__elem_last_index(
        ArrayC_{{typename}} const xs,
        {{type}} const x )
{
    return arrayc_{{funcname}}__elem_last_index_by( xs, x, equalf );
}


{{type}} const *
arrayc_{{funcname}}__elem_last_ptr(
        ArrayC_{{typename}} const xs,
        {{type}} const x )
{
    return arrayc_{{funcname}}__elem_last_ptr_by( xs, x, equalf );
}


size_t
arrayc_{{funcname}}__elem_count(
        ArrayC_{{typename}} const xs,
        {{type}} const x )
{
    return arrayc_{{funcname}}__elem_count_by( xs, x, equalf );
}


ArrayM_{{typename}}
arrayc_{{funcname}}__replaced(
        ArrayC_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__replaced_by( xs, el, repl, equalf );
}




bool
arraym_{{funcname}}__equal(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ) );

    return arraym_{{funcname}}__equal_by( xs, ys, equalf );
}


bool
arraym_{{funcname}}__not_equal(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ) );

    return !arraym_{{funcname}}__equal( xs, ys );
}


bool
arraym_{{funcname}}__first_is(
        ArrayM_{{typename}} const xs,
        {{type}} const e )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__first_is(
               arrayc_{{funcname}}__view_arraym( xs ), e );
}


bool
arraym_{{funcname}}__last_is(
        ArrayM_{{typename}} const xs,
        {{type}} const e )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__last_is(
               arrayc_{{funcname}}__view_arraym( xs ), e );
}


bool
arraym_{{funcname}}__has_prefix(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ) );

    return arraym_{{funcname}}__has_prefix_by( xs, ys, equalf );
}


bool
arraym_{{funcname}}__has_suffix(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ) );

    return arraym_{{funcname}}__has_suffix_by( xs, ys, equalf );
}


bool
arraym_{{funcname}}__has_infix(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ) );

    return arraym_{{funcname}}__has_infix_by( xs, ys, equalf );
}


Maybe_size
arraym_{{funcname}}__infix_index(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ) );

    return arraym_{{funcname}}__infix_index_by( xs, ys, equalf );
}


Maybe_size
arraym_{{funcname}}__last_infix_index(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ) );

    return arraym_{{funcname}}__last_infix_index_by( xs, ys, equalf );
}


bool
arraym_{{funcname}}__elem(
        ArrayM_{{typename}} const xs,
        {{type}} const x )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__elem_by( xs, x, equalf );
}


Maybe_size
arraym_{{funcname}}__elem_index(
        ArrayM_{{typename}} const xs,
        {{type}} const x )
{
    return arraym_{{funcname}}__elem_index_by( xs, x, equalf );
}


{{type}} *
arraym_{{funcname}}__elem_ptr(
        ArrayM_{{typename}} const xs,
        {{type}} const x )
{
    return arraym_{{funcname}}__elem_ptr_by( xs, x, equalf );
}


Maybe_size
arraym_{{funcname}}__elem_last_index(
        ArrayM_{{typename}} const xs,
        {{type}} const x )
{
    return arraym_{{funcname}}__elem_last_index_by( xs, x, equalf );
}


{{type}} *
arraym_{{funcname}}__elem_last_ptr(
        ArrayM_{{typename}} const xs,
        {{type}} const x )
{
    return arraym_{{funcname}}__elem_last_ptr_by( xs, x, equalf );
}


size_t
arraym_{{funcname}}__elem_count(
        ArrayM_{{typename}} const xs,
        {{type}} const x )
{
    return arraym_{{funcname}}__elem_count_by( xs, x, equalf );
}


void
arraym_{{funcname}}__replace(
        ArrayM_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    arraym_{{funcname}}__replace_by( xs, el, repl, equalf );
}


ArrayM_{{typename}}
arraym_{{funcname}}__replaced(
        ArrayM_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__replaced_by( xs, el, repl, equalf );
}


{% endif %} {# EQ #}




{% if 'ORD' in typeclasses %}


static
ord
cmpf(
        {{type}} const x,
        {{type}} const y )
{
    // `__compare()` might be defined as a type-generic macro:
    return {{funcname}}__compare( x, y );
}


ord
arrayc_{{funcname}}__compare(
        ArrayC_{{typename}} const xs,
        ArrayC_{{typename}} const ys )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ),
            arrayc_{{funcname}}__is_valid( ys ) );

    return arrayc_{{funcname}}__compare_by( xs, ys, cmpf );
}


bool
arrayc_{{funcname}}__is_ascending(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__is_ascending_by( xs, cmpf );
}


bool
arrayc_{{funcname}}__is_strictly_ascending(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__is_strictly_ascending_by( xs, cmpf );
}


bool
arrayc_{{funcname}}__is_descending(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__is_descending_by( xs, cmpf );
}


bool
arrayc_{{funcname}}__is_strictly_descending(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__is_strictly_descending_by( xs, cmpf );
}


{{type}}
arrayc_{{funcname}}__minimum(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__minimum_by( xs, cmpf );
}


{{type}}
arrayc_{{funcname}}__maximum(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__maximum_by( xs, cmpf );
}


ord
arraym_{{funcname}}__compare(
        ArrayM_{{typename}} const xs,
        ArrayM_{{typename}} const ys )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ),
            arraym_{{funcname}}__is_valid( ys ) );

    return arraym_{{funcname}}__compare_by( xs, ys, cmpf );
}


bool
arraym_{{funcname}}__is_ascending(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__is_ascending_by( xs, cmpf );
}


bool
arraym_{{funcname}}__is_strictly_ascending(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__is_strictly_ascending_by( xs, cmpf );
}


bool
arraym_{{funcname}}__is_descending(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__is_descending_by( xs, cmpf );
}


bool
arraym_{{funcname}}__is_strictly_descending(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__is_strictly_descending_by( xs, cmpf );
}


{{type}}
arraym_{{funcname}}__minimum(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__minimum_by( xs, cmpf );
}


{{type}}
arraym_{{funcname}}__maximum(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__maximum_by( xs, cmpf );
}


void
arraym_{{funcname}}__quicksort(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    arraym_{{funcname}}__quicksort_by( xs, cmpf );
}


ArrayM_{{typename}}
arraym_{{funcname}}__quicksorted(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arraym_{{funcname}}__quicksorted_by( xs, cmpf );
}


{% endif %}




{% if 'NULL' in typeclasses %}


#include <limits.h>


static
size_t
buflen(
        {{type}} const * const buf )
{
    if ( buf == NULL ) {
        return 0;
    } else {
        size_t count = 0;
        while ( !{{funcname}}__is_null( buf[ count ] ) ) {
            count++;
            ASSERT( count < SIZE_MAX );
        }
        return count;
    }
}


ArrayC_{{typename}}
arrayc_{{funcname}}__view_buf(
        {{type}} const * const buf )
{
    return arrayc_{{funcname}}__new( buf, buflen( buf ) );
}


ArrayC_{{typename}}
arrayc_{{funcname}}__view_buf0(
        {{type}} const * const buf )
{
    size_t const sz = buflen( buf );
    ASSERT( sz < SIZE_MAX );
    return arrayc_{{funcname}}__new( buf, sz + 1 );
}


bool
arrayc_{{funcname}}__last_is_null(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    {{type}} const * const lastp = arrayc_{{funcname}}__lastp( xs );
    return lastp != NULL && {{funcname}}__is_null( *lastp );
}


bool
arrayc_{{funcname}}__all_null(
        ArrayC_{{typename}} const xs )
{
    ASSERT( arrayc_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__all( xs, {{funcname}}__is_null );
}


ArrayM_{{typename}}
arraym_{{funcname}}__view_buf(
        {{type}} * const buf )
{
    return arraym_{{funcname}}__new_view( buf, buflen( buf ) );
}


ArrayM_{{typename}}
arraym_{{funcname}}__view_buf0(
        {{type}} * const buf )
{
    size_t const sz = buflen( buf );
    ASSERT( sz < SIZE_MAX );
    return arraym_{{funcname}}__new_view( buf, sz + 1 );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_buf(
        {{type}} const * const buf )
{
    return arraym_{{funcname}}__copy_buf_with( buf, NULL );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_buf_with(
        {{type}} const * const buf,
        void ( * const copier )( {{type}} * new_el, {{type}} buf_el ) )
{
    return arraym_{{funcname}}__copy_arrayc_with(
               arrayc_{{funcname}}__view_buf( buf ), copier );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_buf0(
        {{type}} const * const buf )
{
    return arraym_{{funcname}}__copy_buf0_with( buf, NULL );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_buf0_with(
        {{type}} const * const buf,
        void ( * const copier )( {{type}} * new_el, {{type}} buf_el ) )
{
    return arraym_{{funcname}}__copy_arrayc_with(
               arrayc_{{funcname}}__view_buf0( buf ), copier );
}


void
arraym_{{funcname}}__copy_buf_into(
        ArrayM_{{typename}} * const to,
        {{type}} const * const buf )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ) );

    arraym_{{funcname}}__copy_buf_into_with( to, buf, NULL, NULL );
}


void
arraym_{{funcname}}__copy_buf_into_with(
        ArrayM_{{typename}} * const to,
        {{type}} const * const buf,
        void ( * const copier )( {{type}} * to_el, {{type}} buf_el ),
        void ( * const freer )( {{type}} * unused_to_el ) )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ) );

    arraym_{{funcname}}__copy_arrayc_into_with(
        to, arrayc_{{funcname}}__view_buf( buf ), copier, freer );
}


void
arraym_{{funcname}}__copy_buf0_into(
        ArrayM_{{typename}} * const to,
        {{type}} const * const buf )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ) );

    arraym_{{funcname}}__copy_buf0_into_with( to, buf, NULL, NULL );
}


void
arraym_{{funcname}}__copy_buf0_into_with(
        ArrayM_{{typename}} * const to,
        {{type}} const * const buf,
        void ( * const copier )( {{type}} * to_el, {{type}} buf_el ),
        void ( * const freer )( {{type}} * unused_to_el ) )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ) );

    arraym_{{funcname}}__copy_arrayc_into_with(
        to, arrayc_{{funcname}}__view_buf0( buf ), copier, freer );
}


bool
arraym_{{funcname}}__last_is_null(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__last_is_null(
               arrayc_{{funcname}}__view_arraym( xs ) );
}


bool
arraym_{{funcname}}__all_null(
        ArrayM_{{typename}} const xs )
{
    ASSERT( arraym_{{funcname}}__is_valid( xs ) );

    return arrayc_{{funcname}}__all_null(
               arrayc_{{funcname}}__view_arraym( xs ) );
}


{% if 'EQ' in typeclasses %}


bool
arrayc_{{funcname}}__equal_buf(
        ArrayC_{{typename}} const xs,
        {{type}} const * const buf )
{
    return arrayc_{{funcname}}__equal(
               xs, arrayc_{{funcname}}__view_buf( buf ) );
}


bool
arrayc_{{funcname}}__equal_buf0(
        ArrayC_{{typename}} const xs,
        {{type}} const * const buf )
{
    return arrayc_{{funcname}}__equal(
               xs, arrayc_{{funcname}}__view_buf0( buf ) );
}


bool
arraym_{{funcname}}__equal_buf(
        ArrayM_{{typename}} const xs,
        {{type}} const * const buf )
{
    return arrayc_{{funcname}}__equal_buf(
               arrayc_{{funcname}}__view_arraym( xs ), buf );
}


bool
arraym_{{funcname}}__equal_buf0(
        ArrayM_{{typename}} const xs,
        {{type}} const * const buf )
{
    return arrayc_{{funcname}}__equal_buf0(
               arrayc_{{funcname}}__view_arraym( xs ), buf );
}


{% endif %} {# EQ #}

{% endif %} {# NULL #}


{% if 'CHAR' in typeclasses %}


#include <libstr/str.h>


void
arraym_{{funcname}}__copy_in_str(
        ArrayM_{{typename}} to,
        char const * const str )
{
    ASSERT( arraym_{{funcname}}__is_valid( to ) );

    arraym_{{funcname}}__copy_in_str_with( to, str, NULL );
}


void
arraym_{{funcname}}__copy_in_str_with(
        ArrayM_{{typename}} to,
        char const * const str,
        void ( * copier )( {{type}} * to_el, char c ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( to ) );

    size_t const len = str__length( str );
    errno = 0;
    for ( size_t i = 0; i < MIN( to.length, len ); i++ ) {
        {{type}} * const to_el = arraym_{{funcname}}__getp( to, i );
        char const c = str[ i ];
        if ( copier == NULL ) {
            *to_el = {{funcname}}__from_char( c );
        } else {
            copier( to_el, c );
        }
        if ( errno ) { return; }
    }
}


void
arraym_{{funcname}}__copy_in_str0(
        ArrayM_{{typename}} to,
        char const * const str )
{
    ASSERT( arraym_{{funcname}}__is_valid( to ) );

    arraym_{{funcname}}__copy_in_str0_with( to, str, NULL );
}


void
arraym_{{funcname}}__copy_in_str0_with(
        ArrayM_{{typename}} to,
        char const * const str,
        void ( * copier )( {{type}} * to_el, char c ) )
{
    ASSERT( arraym_{{funcname}}__is_valid( to ) );

    size_t const sz = str__size( str );
    errno = 0;
    for ( size_t i = 0; i < MIN( sz, to.length ); i++ ) {
        {{type}} * const to_el = arraym_{{funcname}}__getp( to, i );
        char const c = str[ i ];
        if ( copier == NULL ) {
            *to_el = {{funcname}}__from_char( c );
        } else {
            copier( to_el, c );
        }
        if ( errno ) { return; }
    }
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_str(
        char const * const str )
{
    return arraym_{{funcname}}__copy_str_with( str, NULL );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_str_with(
        char const * const str,
        void ( * copier )( {{type}} * to_el, char c ) )
{
    ArrayM_{{typename}} new =
            arraym_{{funcname}}__new_alloc( str__length( str ) );
    if ( errno ) { return new; }
    arraym_{{funcname}}__copy_in_str_with( new, str, copier );
    return new;
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_str0(
        char const * const str )
{
    return arraym_{{funcname}}__copy_str0_with( str, NULL );
}


ArrayM_{{typename}}
arraym_{{funcname}}__copy_str0_with(
        char const * const str,
        void ( * copier )( {{type}} * to_el, char c ) )
{
    ArrayM_{{typename}} new =
            arraym_{{funcname}}__new_alloc( str__size( str ) );
    if ( errno ) { return new; }
    arraym_{{funcname}}__copy_in_str0_with( new, str, copier );
    return new;
}


void
arraym_{{funcname}}__copy_str_into(
        ArrayM_{{typename}} * const to,
        char const * const str )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ) );

    arraym_{{funcname}}__copy_str_into_with( to, str, NULL, NULL );
}


void
arraym_{{funcname}}__copy_str_into_with(
        ArrayM_{{typename}} * const to,
        char const * const str,
        void ( * const copier )( {{type}} * to_el, char c ),
        void ( * const freer )( {{type}} * unused_to_el ) )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ) );

    arraym_{{funcname}}__realloc_with( to, str__length( str ), freer );
    if ( errno ) { return; }
    arraym_{{funcname}}__copy_in_str_with( *to, str, copier );
}


void
arraym_{{funcname}}__copy_str0_into(
        ArrayM_{{typename}} * const to,
        char const * const str )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ) );

    arraym_{{funcname}}__copy_str0_into_with( to, str, NULL, NULL );
}


void
arraym_{{funcname}}__copy_str0_into_with(
        ArrayM_{{typename}} * const to,
        char const * const str,
        void ( * const copier )( {{type}} * to_el, char c ),
        void ( * const freer )( {{type}} * unused_to_el ) )
{
    ASSERT( to != NULL, arraym_{{funcname}}__is_valid( *to ) );

    arraym_{{funcname}}__realloc_with( to, str__size( str ), freer );
    if ( errno ) { return; }
    arraym_{{funcname}}__copy_in_str0_with( *to, str, copier );
}


{% if 'EQ' in typeclasses %}


bool
arrayc_{{funcname}}__equal_str(
        ArrayC_{{typename}} const xs,
        char const * const str )
{
    size_t const len = str__length( str );
    if ( len != xs.length ) {
        return false;
    }
    for ( size_t i = 0; i < len; i++ ) {
        if ( !{{funcname}}__equal_char( xs.e[ i ], str[ i ] ) ) {
            return false;
        }
    }
    return true;
}


bool
arrayc_{{funcname}}__equal_str0(
        ArrayC_{{typename}} const xs,
        char const * const str )
{
    size_t const sz = str__size( str );
    if ( sz != xs.length ) {
        return false;
    }
    for ( size_t i = 0; i < sz; i++ ) {
        if ( !{{funcname}}__equal_char( xs.e[ i ], str[ i ] ) ) {
            return false;
        }
    }
    return true;
}


bool
arraym_{{funcname}}__equal_str(
        ArrayM_{{typename}} const xs,
        char const * const str )
{
    return arrayc_{{funcname}}__equal_str(
               arrayc_{{funcname}}__view_arraym( xs ), str );
}


bool
arraym_{{funcname}}__equal_str0(
        ArrayM_{{typename}} const xs,
        char const * const str )
{
    return arrayc_{{funcname}}__equal_str0(
               arrayc_{{funcname}}__view_arraym( xs ), str );
}


{% endif %} {# EQ #}

{% endif %} {# CHAR #}

