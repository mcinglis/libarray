
// Copyright 2015  Malcolm Inglis <http://minglis.id.au>
//
// This file is part of Libarray.
//
// Libarray is free software: you can redistribute it and/or modify it under
// the terms of the GNU Affero General Public License as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version.
//
// Libarray is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
// more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with Libarray. If not, see <https://gnu.org/licenses/>.


// This file is the result of rendering:
//
//     {{template_path}}
//
// You should make changes to this file by tuning the build process, or (at a
// stretch) modifying the generation script or template file; not by editing
// this file as-is.


#include "array_{{filename}}.h"

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include <libtypes/types.h>
#include <libmacro/assert.h>
#include <libmacro/logic.h>
#include <libmacro/minmax.h>
#include <libbase/size.h>
#include <libmaybe/maybe_{{filename}}.h>

{% for p in sys_headers %}
#include <{{p}}>
{% endfor %}

{% for p in rel_headers %}
#include "{{p}}"
{% endfor %}


static
void *
reallocn(
        void * const ptr,
        size_t const n,
        size_t const size )
{
    errno = 0;
    size_t const new_size = size__mul( n, size );
    if ( errno ) { return NULL; }
    if ( new_size == 0 ) {
        if ( ptr != NULL ) {
            free( ptr );
        }
        return NULL;
    } else {
        return realloc( ptr, new_size );
    }
}


static
size_t
normalize_index(
        intmax_t const ix,
        size_t const length )
{
    if ( ix >= 0 ) {
        return MIN( ( uintmax_t ) ix, SIZE_MAX );
    } else {
        if ( INTMAX_MAX < SIZE_MAX ) {
            size_t const pos_ix = -ix;
            if ( pos_ix > length ) {
                return 0;
            }
        } else {
            intmax_t const slength = length;
            if ( -slength > ix ) {
                return 0;
            }
        }
        return length + ix;
    }
}


static
Maybe_size
find_index(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ),
        bool const res )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} const * const el = xs.e + i;
        if ( f( *el ) == res ) {
            return ( Maybe_size ){ .value = i };
        }
    }
    return ( Maybe_size ){ .nothing = true };
}


static
Maybe_size
find_last_index(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ),
        bool const res )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    for ( size_t i = xs.length; i > 0; i-- ) {
        size_t const ix = i - 1;
        if ( f( xs.e[ ix ] ) == res ) {
            return ( Maybe_size ){ .value = ix };
        }
    }
    return ( Maybe_size ){ .nothing = true };
}





bool
array_{{funcname}}__is_valid(
        Array_{{typename}} const xs )
{
    return IMPLIES( xs.e == NULL, xs.length == 0 );
}


Array_{{typename}}
array_{{funcname}}__new(
        {{type}} const * const elements,
        size_t const length )
{
    errno = 0;
    Array_{{typename}} const new = array_{{funcname}}__new_alloc( length );
    if ( errno ) { return ( Array_{{typename}} ){ 0 }; }
    array_{{funcname}}__memcpy_in( new, elements,
                                   size__mul( length, sizeof ( {{type}} ) ) );
    return new;
}


Array_{{typename}}
array_{{funcname}}__new_view(
        {{type}} * const elements,
        size_t const length )
{
    if ( elements == NULL ) {
        return ( Array_{{typename}} ){ .e = NULL, .length = 0 };
    } else {
        return ( Array_{{typename}} ){ .e = elements, .length = length };
    }
}


Array_{{typename}}
array_{{funcname}}__new_alloc(
        size_t const length )
{
    Array_{{typename}} new = { 0 };
    array_{{funcname}}__realloc( &new, length );
    return new;
}


Array_{{typename}}
array_{{funcname}}__new_calloc(
        size_t const length )
{
    errno = 0;
    Array_{{typename}} new = array_{{funcname}}__new_alloc( length );
    if ( errno ) { return new; }
    array_{{funcname}}__memzero( new );
    return new;
}


Array_{{typename}}
array_{{funcname}}__copy_array(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__new( xs.e, xs.length );
}


void
array_{{funcname}}__free(
        Array_{{typename}} * const xs )
{
    ASSERT( xs != NULL, array_{{funcname}}__is_valid( *xs ) );

    array_{{funcname}}__realloc( xs, 0 );
}


void
array_{{funcname}}__realloc(
        Array_{{typename}} * const xs,
        size_t const new_length )
{
    ASSERT( xs != NULL, array_{{funcname}}__is_valid( *xs ) );

    if ( new_length != xs->length ) {
        errno = 0;
        {{type}} * const new_e = reallocn( xs->e, new_length,
                                           sizeof ( {{type}} ) );
        if ( errno ) { return; }
        *xs = ( Array_{{typename}} ){ .e = new_e, .length = new_length };
    }
}


void
array_{{funcname}}__memcpy_in(
        Array_{{typename}} const to,
        void const * const from,
        size_t const from_size )
{
    ASSERT( array_{{funcname}}__is_valid( to ), from != NULL );

    memcpy( to.e, from, MIN( from_size, array_{{funcname}}__size( to ) ) );
}


void
array_{{funcname}}__memcpy_to(
        Array_{{typename}} const from,
        void * const to,
        size_t const to_size )
{
    ASSERT( array_{{funcname}}__is_valid( from ), to != NULL );

    memcpy( to, from.e, MIN( to_size, array_{{funcname}}__size( from ) ) );
}


void
array_{{funcname}}__copy_into_array(
        Array_{{typename}} const from,
        Array_{{typename}} const to )
{
    ASSERT( array_{{funcname}}__is_valid( from ),
            array_{{funcname}}__is_valid( to ) );

    array_{{funcname}}__copy_into_array_with( from, to, NULL );
}


void
array_{{funcname}}__copy_into_array_with(
        Array_{{typename}} const from,
        Array_{{typename}} const to,
        void ( * const copier )( {{type}} from_el, {{type}} * to_el ) )
{
    ASSERT( array_{{funcname}}__is_valid( from ),
            array_{{funcname}}__is_valid( to ) );

    errno = 0;
    for ( size_t i = 0; i < MIN( from.length, to.length ); i++ ) {
        {{type}} const from_el = array_{{funcname}}__get( from, i );
        {{type}} * const to_ptr = array_{{funcname}}__getp( to, i );
        if ( copier == NULL ) {
            *to_ptr = from_el;
        } else {
            copier( from_el, to_ptr );
            if ( errno ) { return; }
        }
    }
}


void
array_{{funcname}}__into_array(
        Array_{{typename}} const from,
        Array_{{typename}} * const to )
{
    ASSERT( array_{{funcname}}__is_valid( from ),
            to != NULL, array_{{funcname}}__is_valid( *to ) );

    array_{{funcname}}__into_array_with( from, to, NULL, NULL );
}


void
array_{{funcname}}__into_array_with(
        Array_{{typename}} const from,
        Array_{{typename}} * const to,
        void ( * const copier )( {{type}} from, {{type}} * to ),
        void ( * const freer )( {{type}} * unused_to ) )
{
    ASSERT( array_{{funcname}}__is_valid( from ),
            to != NULL, array_{{funcname}}__is_valid( *to ) );

    array_{{funcname}}__eachp( array_{{funcname}}__drop( *to, from.length ),
                               .f = freer );
    array_{{funcname}}__realloc( to, from.length );
    array_{{funcname}}__copy_into_array_with( from, *to, copier );
}


Array_{{typename}}
array_{{funcname}}__id(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return xs;
}


{{type}} *
array_{{funcname}}__elements(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return xs.e;
}


size_t
array_{{funcname}}__length(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return xs.length;
}


size_t
array_{{funcname}}__size(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            size__can_mul( xs.length, sizeof ( {{type}} ) ) );

    return xs.length * sizeof ( {{type}} );
}


bool
array_{{funcname}}__is_empty(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return xs.length == 0;
}


bool
array_{{funcname}}__isnt_empty(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return !array_{{funcname}}__is_empty( xs );
}


bool
array_{{funcname}}__is_length_1(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return xs.length == 1;
}


bool
array_{{funcname}}__same(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ) );

    return xs.length == ys.length
        && xs.e      == ys.e;
}


{{type}}
array_{{funcname}}__get(
        Array_{{typename}} const xs,
        size_t const index )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), index < xs.length );

    {{type}} * const p = array_{{funcname}}__getp( xs, index );
    ASSERT( p != NULL );
    return *p;
}


{{type}} *
array_{{funcname}}__getp(
        Array_{{typename}} const xs,
        size_t const index )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return ( index < xs.length ) ? ( xs.e + index ) : ( NULL );
}


Maybe_{{typename}}
array_{{funcname}}__getm(
        Array_{{typename}} const xs,
        size_t const index )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return maybe_{{funcname}}__from_ptr(
               array_{{funcname}}__getp( xs, index ) );
}


{{type}}
array_{{funcname}}__set(
        Array_{{typename}} const xs,
        size_t const index,
        {{type}} const value )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), index < xs.length );

    {{type}} * const p = array_{{funcname}}__getp( xs, index );
    ASSERT( p != NULL );
    {{type}} const old = *p;
    *p = value;
    return old;
}


Maybe_{{typename}}
array_{{funcname}}__setm(
        Array_{{typename}} const xs,
        size_t const index,
        {{type}} const value )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return ( index < xs.length )
           ? ( Maybe_{{typename}} ){
                 .value = array_{{funcname}}__set( xs, index, value ) }
           : ( Maybe_{{typename}} ){ .nothing = true };
}


void
array_{{funcname}}__set_all(
        Array_{{typename}} const xs,
        {{type}} const value )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    for ( size_t i = 0; i < xs.length; i++ ) {
        xs.e[ i ] = value;
    }
}


void
array_{{funcname}}__memset(
        Array_{{typename}} const xs,
        uchar const byte )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    memset( xs.e, byte, array_{{funcname}}__size( xs ) );
}


void
array_{{funcname}}__memzero(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    array_{{funcname}}__memset( xs, 0 );
}


{{type}}
array_{{funcname}}__first(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__isnt_empty( xs ) );

    return *( array_{{funcname}}__firstp( xs ) );
}


{{type}} *
array_{{funcname}}__firstp(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__getp( xs, 0 );
}


Maybe_{{typename}}
array_{{funcname}}__firstm(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return maybe_{{funcname}}__from_ptr( array_{{funcname}}__firstp( xs ) );
}


{{type}}
array_{{funcname}}__last(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__isnt_empty( xs ) );

    return *( array_{{funcname}}__lastp( xs ) );
}


{{type}} *
array_{{funcname}}__lastp(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__getp( xs, xs.length - 1 );
}


Maybe_{{typename}}
array_{{funcname}}__lastm(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return maybe_{{funcname}}__from_ptr( array_{{funcname}}__lastp( xs ) );
}


size_t
array_{{funcname}}__count(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    size_t count = 0;
    for ( size_t i = 0; i < xs.length; i++ ) {
        if ( f( xs.e[ i ] ) ) {
            count++;
        }
    }
    return count;
}


size_t
array_{{funcname}}__count_first(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    size_t count = 0;
    for ( size_t i = 0; i < xs.length; i++ ) {
        if ( f( xs.e[ i ] ) ) {
            count++;
        } else {
            break;
        }
    }
    return count;
}


size_t
array_{{funcname}}__count_last(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    size_t count = 0;
    for ( size_t i = xs.length; i > 0; i-- ) {
        if ( f( xs.e[ i - 1 ] ) ) {
            count++;
        } else {
            break;
        }
    }
    return count;
}


Array_{{typename}}
array_{{funcname}}__take(
        Array_{{typename}} const xs,
        size_t const n )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return xs;
    } else {
        return ( Array_{{typename}} ){
                   .e      = xs.e,
                   .length = n };
    }
}


Array_{{typename}}
array_{{funcname}}__drop(
        Array_{{typename}} const xs,
        size_t const n )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return ( Array_{{typename}} ){ .e = NULL, .length = 0 };
    } else {
        return ( Array_{{typename}} ){
                   .e      = xs.e + n,
                   .length = xs.length - n };
    }
}


Array_{{typename}}
array_{{funcname}}__take_end(
        Array_{{typename}} const xs,
        size_t const n )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return xs;
    } else {
        return array_{{funcname}}__drop( xs, xs.length - n );
    }
}


Array_{{typename}}
array_{{funcname}}__drop_end(
        Array_{{typename}} const xs,
        size_t const n )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    if ( n >= xs.length ) {
        return ( Array_{{typename}} ){ .e = NULL, .length = 0 };
    } else {
        return array_{{funcname}}__take( xs, xs.length - n );
    }
}


Array_{{typename}}
array_{{funcname}}__take_while(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__take(
               xs,
               array_{{funcname}}__count_first( xs, f ) );
}


Array_{{typename}}
array_{{funcname}}__take_end_while(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__take_end(
               xs,
               array_{{funcname}}__count_last( xs, f ) );
}


Array_{{typename}}
array_{{funcname}}__drop_while(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__drop(
               xs,
               array_{{funcname}}__count_first( xs, f ) );
}


Array_{{typename}}
array_{{funcname}}__drop_end_while(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__drop_end(
               xs,
               array_{{funcname}}__count_last( xs, f ) );
}


Array_{{typename}}
array_{{funcname}}__slice(
        Array_{{typename}} const xs,
        size_t const start,
        size_t const stop )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__drop(
               array_{{funcname}}__take( xs, stop ),
               start );
}


Array_{{typename}}
array_{{funcname}}__slice_s(
        Array_{{typename}} const xs,
        intmax_t const start,
        intmax_t const stop )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__slice(
               xs,
               normalize_index( start, xs.length ),
               normalize_index( stop, xs.length ) );
}


Array_{{typename}}
array_{{funcname}}__left_half(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__take( xs, xs.length / 2 );
}


Array_{{typename}}
array_{{funcname}}__right_half(
        Array_{{typename}} const xs )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__drop( xs, xs.length / 2 );
}


Maybe_size
array_{{funcname}}__find(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return find_index( xs, f, true );
}


Maybe_size
array_{{funcname}}__find_not(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return find_index( xs, f, false );
}


Maybe_size
array_{{funcname}}__find_last(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return find_last_index( xs, f, true );
}


Maybe_size
array_{{funcname}}__find_last_not(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return find_last_index( xs, f, false );
}


{{type}} *
array_{{funcname}}__findp(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = array_{{funcname}}__find( xs, f );
    return mi.nothing ? NULL : ( xs.e + mi.value );
}


{{type}} *
array_{{funcname}}__findp_not(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = array_{{funcname}}__find_not( xs, f );
    return mi.nothing ? NULL : ( xs.e + mi.value );
}


{{type}} *
array_{{funcname}}__findp_last(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = array_{{funcname}}__find_last( xs, f );
    return mi.nothing ? NULL : ( xs.e + mi.value );
}


{{type}} *
array_{{funcname}}__findp_last_not(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    Maybe_size const mi = array_{{funcname}}__find_last_not( xs, f );
    return mi.nothing ? NULL : ( xs.e + mi.value );
}


Maybe_{{typename}}
array_{{funcname}}__findm(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return maybe_{{funcname}}__from_ptr(
               array_{{funcname}}__findp( xs, f ) );
}


Maybe_{{typename}}
array_{{funcname}}__findm_not(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return maybe_{{funcname}}__from_ptr(
               array_{{funcname}}__findp_not( xs, f ) );
}


Maybe_{{typename}}
array_{{funcname}}__findm_last(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return maybe_{{funcname}}__from_ptr(
               array_{{funcname}}__findp_last( xs, f ) );
}


Maybe_{{typename}}
array_{{funcname}}__findm_last_not(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return maybe_{{funcname}}__from_ptr(
               array_{{funcname}}__findp_last_not( xs, f ) );
}


bool
array_{{funcname}}__any(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__findp( xs, f ) != NULL;
}


bool
array_{{funcname}}__all(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    return array_{{funcname}}__findp_not( xs, f ) == NULL;
}


bool
array_{{funcname}}__only_one(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} const * const first = array_{{funcname}}__findp( xs, f );
    if ( first == NULL ) {
        return false;
    } else {
        return first == array_{{funcname}}__findp_last( xs, f );
    }
}


bool
array_{{funcname}}__all_but_one(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} const * const first = array_{{funcname}}__findp_not( xs, f );
    if ( first == NULL ) {
        return false;
    } else {
        return first == array_{{funcname}}__findp_last_not( xs, f );
    }
}


{{type}}
array_{{funcname}}__foldl(
        Array_{{typename}} const xs,
        {{type}} const init,
        {{type}} ( * const f )( {{type}} acc, {{type}} x ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} acc = init;
    for ( size_t i = 0; i < xs.length; i++ ) {
        acc = f( acc, xs.e[ i ] );
    }
    return acc;
}


{{type}}
array_{{funcname}}__foldl1(
        Array_{{typename}} xs,
        {{type}} ( * f )( {{type}} acc, {{type}} x ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), xs.length > 0, f != NULL );

    return array_{{funcname}}__foldl(
               array_{{funcname}}__drop( xs, 1 ),
               array_{{funcname}}__first( xs ),
               f );
}


{{type}}
array_{{funcname}}__foldr(
        Array_{{typename}} xs,
        {{type}} init,
        {{type}} ( * f )( {{type}} x, {{type}} acc ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} acc = init;
    for ( size_t i = xs.length; i > 0; i-- ) {
        acc = f( xs.e[ i - 1 ], acc );
    }
    return acc;
}


{{type}}
array_{{funcname}}__foldr1(
        Array_{{typename}} xs,
        {{type}} ( * f )( {{type}} x, {{type}} acc ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), xs.length > 0, f != NULL );

    return array_{{funcname}}__foldr(
               array_{{funcname}}__drop_end( xs, 1 ),
               array_{{funcname}}__last( xs ),
               f );
}


{{type}} *
array_{{funcname}}__pick(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} * pick, {{type}} x ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    {{type}} * pick = NULL;
    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} * const el = xs.e + i;
        if ( f( pick, *el ) ) {
            pick = el;
        }
    }
    return pick;
}


bool
array_{{funcname}}__equal_by(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), eq != NULL );

    if ( xs.length != ys.length ) { return false; }
    if ( xs.e == ys.e ) { return true; }
    for ( size_t i = 0; i < xs.length; i++ ) {
        if ( !eq( xs.e[ i ], ys.e[ i ] ) ) {
            return false;
        }
    }
    return true;
}


bool
array_{{funcname}}__has_prefix_by(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return array_{{funcname}}__equal_by(
               array_{{funcname}}__take( xs, ys.length ), ys, eq );
}


bool
array_{{funcname}}__has_suffix_by(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return array_{{funcname}}__equal_by(
               array_{{funcname}}__take_end( xs, ys.length ), ys, eq );
}


bool
array_{{funcname}}__has_infix_by(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ),
            eq != NULL );

    return !( array_{{funcname}}__infix_index_by( xs, ys, eq ).nothing );
}


Maybe_size
array_{{funcname}}__infix_index_by(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ),
            eq != NULL );

    for ( size_t i = 0; i < xs.length; i++ ) {
        Array_{{typename}} const xs_rest = array_{{funcname}}__drop( xs, i );
        if ( array_{{funcname}}__has_prefix_by( xs_rest, ys, eq ) ) {
            return ( Maybe_size ){ .value = i };
        }
    }
    return ( Maybe_size ){ .nothing = true };
}


{{type}} *
array_{{funcname}}__infix_ptr_by(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ),
            eq != NULL );

    Maybe_size const mi = array_{{funcname}}__infix_index_by( xs, ys, eq );
    return mi.nothing ? NULL : array_{{funcname}}__getp( xs, mi.value );
}


size_t
array_{{funcname}}__infix_count_by(
        Array_{{typename}} xs,
        Array_{{typename}} const ys,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ),
            eq != NULL );

    size_t count = 0;
    Maybe_size mi;
    while ( mi = array_{{funcname}}__infix_index_by( xs, ys, eq ),
            !mi.nothing ) {
        xs = array_{{funcname}}__drop( xs, mi.value + 1 );
        count++;
    }
    return count;
}


bool
array_{{funcname}}__elem_by(
        Array_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), eq != NULL );

    return array_{{funcname}}__elem_ptr_by( xs, y, eq ) != NULL;
}


{{type}} *
array_{{funcname}}__elem_ptr_by(
        Array_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), eq != NULL );

    Maybe_size const mi = array_{{funcname}}__elem_index_by( xs, y, eq );
    return mi.nothing ? NULL : array_{{funcname}}__getp( xs, mi.value );
}


Maybe_size
array_{{funcname}}__elem_index_by(
        Array_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), eq != NULL );

    for ( size_t i = 0; i < xs.length; i++ ) {
        if ( eq( xs.e[ i ], y ) ) {
            return ( Maybe_size ){ .value = i };
        }
    }
    return ( Maybe_size ){ .nothing = true };
}


size_t
array_{{funcname}}__elem_count_by(
        Array_{{typename}} const xs,
        {{type}} const y,
        bool ( * const eq )( {{type}} x, {{type}} y ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), eq != NULL );

    size_t count = 0;
    for ( size_t i = 0; i < xs.length; i++ ) {
        if ( eq( xs.e[ i ], y ) ) {
            count++;
        }
    }
    return count;
}


void
array_{{funcname}}__replacef(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} x ),
        {{type}} const repl )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} * const x = xs.e + i;
        if ( f( *x ) == true ) {
            *x = repl;
        }
    }
}


Array_{{typename}}
array_{{funcname}}__replacedf(
        Array_{{typename}} const xs,
        bool ( * const f )( {{type}} x ),
        {{type}} const repl )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), f != NULL );

    errno = 0;
    Array_{{typename}} const new = array_{{funcname}}__copy_array( xs );
    if ( errno ) { return ( Array_{{typename}} ){ 0 }; }
    array_{{funcname}}__replacef( new, f, repl );
    return new;
}


void
array_{{funcname}}__replace_by(
        Array_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} el ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), eq != NULL );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} * const x = xs.e + i;
        if ( eq( *x, el ) == true ) {
            *x = repl;
        }
    }
}


Array_{{typename}}
array_{{funcname}}__replaced_by(
        Array_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl,
        bool ( * const eq )( {{type}} x, {{type}} el ) )
{
    ASSERT( array_{{funcname}}__is_valid( xs ), eq != NULL );

    errno = 0;
    Array_{{typename}} const new = array_{{funcname}}__copy_array( xs );
    if ( errno ) { return ( Array_{{typename}} ){ 0 }; }
    array_{{funcname}}__replace_by( new, el, repl, eq );
    return new;
}


bool
array_{{funcname}}__each_(
        Array_{{typename}} const xs,
        struct array_{{funcname}}__each__options const o )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} const el = array_{{funcname}}__get( xs, i );
        if ( ( o.where != NULL && !o.where( el ) )
          || ( o.where_not != NULL && o.where_not( el ) ) ) {
            continue;
        }
        errno = 0;
        if ( o.f != NULL ) {
            o.f( el );
        } else if ( o.b != NULL ) {
            if ( o.b( el ) == false ) { return false; }
        } else if ( o.fi != NULL ) {
            o.fi( i, el );
        } else if ( o.bi != NULL ) {
            if ( o.bi( i, el ) == false ) { return false; }
        } else if ( o.fv != NULL ) {
            o.fv( o.v, el );
        } else if ( o.bv != NULL ) {
            if ( o.bv( o.v, el ) == false ) { return false; }
        } else if ( o.fvi != NULL ) {
            o.fvi( o.v, i, el );
        } else if ( o.bvi != NULL ) {
            if ( o.bvi( o.v, i, el ) == false ) { return false; }
        }
        if ( errno ) { return false; }
    }
    return true;
}


bool
array_{{funcname}}__eachp_(
        Array_{{typename}} const xs,
        struct array_{{funcname}}__eachp__options const o )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    for ( size_t i = 0; i < xs.length; i++ ) {
        {{type}} * const el = array_{{funcname}}__getp( xs, i );
        if ( ( o.where != NULL && !o.where( *el ) )
          || ( o.where_not != NULL && o.where_not( *el ) ) ) {
            continue;
        }
        errno = 0;
        if ( o.f != NULL ) {
            o.f( el );
        } else if ( o.b != NULL ) {
            if ( o.b( el ) == false ) { return false; }
        } else if ( o.fi != NULL ) {
            o.fi( i, el );
        } else if ( o.bi != NULL ) {
            if ( o.bi( i, el ) == false ) { return false; }
        } else if ( o.fv != NULL ) {
            o.fv( o.v, el );
        } else if ( o.bv != NULL ) {
            if ( o.bv( o.v, el ) == false ) { return false; }
        } else if ( o.fvi != NULL ) {
            o.fvi( o.v, i, el );
        } else if ( o.bvi != NULL ) {
            if ( o.bvi( o.v, i, el ) == false ) { return false; }
        }
        if ( errno ) { return false; }
    }
    return true;
}




{% macro typeclass_header(name) -%}
///////////////////////////////////
/// TYPECLASS: {{name}}
///////////////////////////////////
{%- endmacro %}

{% macro typeclass(name) -%}
{% if name in typeclasses %}
{{ typeclass_header(name) }}
{{ caller() }}
{% endif %}
{%- endmacro %}


{% call typeclass('EQ') %}


static
bool
equalf(
        {{type}} const x,
        {{type}} const y )
{
    // `__equal()` might be defined as a type-generic macro:
    return {{funcname}}__equal( x, y );
}


bool
array_{{funcname}}__equal(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ) );

    return array_{{funcname}}__equal_by( xs, ys, equalf );
}


bool
array_{{funcname}}__not_equal(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ) );

    return !array_{{funcname}}__equal( xs, ys );
}


bool
array_{{funcname}}__has_prefix(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ) );

    return array_{{funcname}}__has_prefix_by( xs, ys, equalf );
}


bool
array_{{funcname}}__has_suffix(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ) );

    return array_{{funcname}}__has_prefix_by( xs, ys, equalf );
}


bool
array_{{funcname}}__has_infix(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ) );

    return array_{{funcname}}__has_infix_by( xs, ys, equalf );
}


Maybe_size
array_{{funcname}}__infix_index(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ) );

    return array_{{funcname}}__infix_index_by( xs, ys, equalf );
}


{{type}} *
array_{{funcname}}__infix_ptr(
        Array_{{typename}} const xs,
        Array_{{typename}} const ys )
{
    ASSERT( array_{{funcname}}__is_valid( xs ),
            array_{{funcname}}__is_valid( ys ) );

    return array_{{funcname}}__infix_ptr_by( xs, ys, equalf );
}


bool
array_{{funcname}}__elem(
        Array_{{typename}} const xs,
        {{type}} const x )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__elem_by( xs, x, equalf );
}


{{type}} *
array_{{funcname}}__elem_ptr(
        Array_{{typename}} const xs,
        {{type}} const x )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__elem_ptr_by( xs, x, equalf );
}


Maybe_size
array_{{funcname}}__elem_index(
        Array_{{typename}} const xs,
        {{type}} const x )
{
    return array_{{funcname}}__elem_index_by( xs, x, equalf );
}


size_t
array_{{funcname}}__elem_count(
        Array_{{typename}} const xs,
        {{type}} const x )
{
    return array_{{funcname}}__elem_count_by( xs, x, equalf );
}


void
array_{{funcname}}__replace(
        Array_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    array_{{funcname}}__replace_by( xs, el, repl, equalf );
}


Array_{{typename}}
array_{{funcname}}__replaced(
        Array_{{typename}} const xs,
        {{type}} const el,
        {{type}} const repl )
{
    ASSERT( array_{{funcname}}__is_valid( xs ) );

    return array_{{funcname}}__replaced_by( xs, el, repl, equalf );
}


{% endcall %}


{% call typeclass('NUM') %}


#include <string.h>


static
size_t
strlen_null(
        {{type}} const * const xs )
{
    if ( xs == NULL ) { return 0; }
    size_t count = 0;
    while ( !{{funcname}}__equal( xs[ count ], {{funcname}}__zero() ) ) {
        count++;
    }
    return count;
}


Array_{{typename}}
array_{{funcname}}__view_str(
        {{type}} * const xs )
{
    return array_{{funcname}}__new_view( xs, strlen_null( xs ) );
}


Array_{{typename}}
array_{{funcname}}__copy_str(
        {{type}} const * const xs )
{
    return array_{{funcname}}__new( xs, strlen_null( xs ) );
}


{% endcall %}

